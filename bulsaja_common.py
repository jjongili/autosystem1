# -*- coding: utf-8 -*-
"""
불사자 공통 모듈 (bulsaja_common.py)

모든 불사자 관련 프로그램에서 공유하는:
- 키워드 (금지/예외/제거/미끼옵션)
- API 클라이언트
- 유틸리티 함수

사용:
    from bulsaja_common import *

by 프코노미
"""

import os
import re
import json
import requests
import websocket
from typing import List, Dict, Tuple, Optional, Set
from urllib.parse import urlparse

# ==================== 파일 경로 ====================
BANNED_WORDS_FILE = "banned_words.json"      # 금지단어 (브랜드/위험상품)
EXCLUDED_WORDS_FILE = "excluded_words.json"  # 예외단어 (탐지 제외)
REMOVE_WORDS_FILE = "remove_words.json"      # 제거단어 (상품명에서 삭제)
BAIT_KEYWORDS_FILE = "bait_keywords.json"    # 미끼옵션 키워드

# ==================== 상품명 관련 키워드 (title_maker) ====================

# 성인/성관련 단어
ADULT_KEYWORDS = {
    "성인용품", "섹시속옷", "섹시란제리", "란제리", "가터벨트",
    "코르셋", "나이트웨어", "베이비돌",
    "시스루", "야한", "에로틱", "19금",
    "콘돔", "러브젤", "바이브레이터", "딜도", "오나홀", "리얼돌",
    "본디지", "페티쉬", "코스프레의상",
    "끈팬티", "티팬티", "누드",
    # 'SM', '테디', '캐미솔', '노출', '채찍', '메이드복' 제거 - 오탐 가능
}

# 의료기기/의료 관련 단어
MEDICAL_KEYWORDS = {
    "의료기기", "의료용", "의약품", "처방전", "혈압계", "혈당계",
    "체온계", "산소포화도", "심전도", "엑스레이",
    "주사기", "주사바늘", "수액세트", "링거", "카테터", "스텐트",
    "보청기", "콘택트렌즈", "시력교정",
    "휠체어", "목발", "의족", "의수", "깁스",
    "진통제", "해열제", "항생제",
    "스테로이드", "호르몬제", "피임약", "발기부전약", "탈모약", "다이어트약",
    "건강기능식품", "영양제", "프로폴리스", "오메가3",
    "유산균", "프로바이오틱스", "글루코사민",
    "LED마스크", "피부관리기",
    # 레이저/IPL 미용기기 (의료기기법 위반)
    "레이저제모기", "IPL제모기", "제모기", "문신제거기", "타투제거기",
    # 'MRI', 'CT', 'IPL', '약품', '맥박', '임플란트', '치과', '교정기', '틀니', '의치',
    # '소독제', '살균제', '멸균', '수술', '마취', '비타민', '홍삼', '콜라겐', '히알루론산' 제거
    # - 일반 제품명에서 오탐 가능
}

# 유아/아동 관련 (구매대행 금지)
# ※ 안전 컨텍스트(책상, 의자, 문구 등)가 있으면 무시됨
CHILD_KEYWORDS = {
    "유아용품", "유아용", "신생아용", "영아용",
    "젖병", "분유", "이유식", "기저귀",
    "아기띠", "카시트", "바운서", "보행기", "점퍼루",
    "유아복", "아기옷", "배냇저고리",
    "수유쿠션", "수유브라", "유축기",
    "치발기", "공갈젖꼭지", "딸랑이",
    # '유아', '아기', '베이비', 'baby', 'infant' 제거 - 베이비파우더, 아기피부 등 오탐
    # '물티슈', '캐리어', '턱받이', '손싸개', '발싸개' 제거 - 일반 제품에서 오탐
    # '장난감', '토이', '인형', '레고' 제거 - 성인용 피규어, 인형 등 오탐
    # '수유', '모유', '젖꼭지', '노리개', '모빌' 제거 - 오탐 가능
    # '아동복', '키즈', '주니어', '어린이', '초등', '유치원' 제거 - 책상, 가구 등 오탐 (안전컨텍스트로 처리)
}

# 판매금지/규제 상품
# ※ 안전 컨텍스트(랙, 잔, 선반 등)가 있으면 무시됨
# ※ 2026-01-15 PPT "지재권 위험 리스트" 기반 대폭 업데이트
PROHIBITED_KEYWORDS = {
    # ==================== 자전거 관련 ====================
    "픽시자전거", "고정기어자전거", "브레이크없는자전거",

    # ==================== 안전인증 필요 가전 ====================
    "가스렌지", "가스레인지", "전기장판", "전기매트", "전기담요",
    "온수매트", "전기히터", "석유난로", "가스난로",

    # ==================== 화장품 ====================
    "화장품", "스킨케어", "마스크팩",
    "샴푸", "린스", "트리트먼트", "바디워시",

    # ==================== 무기류 (PPT 슬라이드 5,6) ====================
    "도검", "권총", "소총", "비비탄총", "에어건", "석궁",
    "화약", "폭죽", "불꽃놀이",
    "칼", "사시미칼", "회칼", "식칼", "과도",  # 칼 종류
    "모형총", "BB탄총", "BB탄", "너클", "전투칼", "나이프",
    "소음기", "레이저조준기", "조준경", "도트사이트",  # 총포류 관련

    # ==================== 타정기/전기충격기 (PPT 슬라이드 2,3) ====================
    "타정총", "타정기", "타카총", "타카건", "타카",
    "전기충격기", "스턴건", "호신용충격기",
    # 동물학대 도구 (전기채, 전기봉)
    "전기채", "전기봉", "돼지몰이", "소몰이", "가축몰이", "축산전기봉",

    # ==================== 경찰/군용품 (PPT 슬라이드 7) ====================
    # 전투복/위장복/군용은 밀리터리 패션으로 허용 (안전 컨텍스트로 처리)
    "경찰제복", "경찰복", "수갑", "경찰봉", "삼단봉",
    "군복",  # 실제 군복만 금지 (전투복, 위장복, 군용은 패션으로 허용)

    # ==================== 레이저 관련 (PPT 슬라이드 8) ====================
    # 레이저포인터만 금지 (레이저레벨기/줄자/측정기는 공구이므로 허용)
    "레이저포인터",

    # ==================== 가스/연료 관련 (PPT 슬라이드 19,20) ====================
    "가스통", "가스버너", "부탄가스", "프로판가스",
    "휴대용가스", "캠핑가스", "가스토치",
    "에어컨냉매", "냉매가스", "프레온가스",

    # ==================== 어업/포획 도구 (PPT 슬라이드 16,17) ====================
    "작살총", "작살", "어망", "투망", "자망", "그물",
    "동물덫", "포획망", "올무", "쥐덫",

    # ==================== 담배/주류 ====================
    "담배", "전자담배", "니코틴", "베이프",

    # ==================== 도박 ====================
    "도박", "슬롯머신", "베팅",

    # ==================== 복제품 ====================
    "짝퉁", "이미테이션", "레플리카",

    # ==================== 배터리 (PPT 슬라이드 27) ====================
    "리튬배터리", "대용량배터리", "보조배터리팩",

    # ==================== 생활화학 (PPT 슬라이드 26) ====================
    "접착제", "에폭시", "본드", "글루건심",
    "페인트", "락카", "도료", "시너",
    "세제", "표백제", "살충제", "제초제",
    # 제습제/방습제 (생활화학제품)
    "제습제", "방습제", "실리카겔", "습기제거제",

    # ==================== 원물/자연물 (PPT 슬라이드 25) ====================
    "원목통나무", "원석", "흙", "모래",  # 가공되지 않은 자연물

    # ==================== 차량용 불법조명 (PPT 슬라이드 28) ====================
    "트럭조명", "화물차조명", "불법조명",

    # ==================== 의료기기/자세교정 (PPT 슬라이드 34) ====================
    # 치료 목적 키워드 (마사지기와 구분)
    "통증완화", "디스크완화", "치료용", "교정기", "자세교정기",
    "척추교정", "골반교정", "거북목교정",
    # 테라헤르츠/고주파 의료기기 (허위/과대광고 + 의료기기법 위반)
    "테라헤르츠", "테라헤르쯔", "고주파치료", "고주파치료기",
    "올리라이프", "olylife", "P100",
    "원적외선치료", "적외선치료기", "바이오매트",

    # ==================== 성인용품 (PPT 슬라이드 24) ====================
    "성인용품", "성인토이",

    # ==================== 속옷/의류 (위생/반품 문제) ====================
    # "브라"는 브라켓/브라이덜/래브라도 등 오탐 많아서 제거
    # "브래지어", "빵브라", "노와이어브라", "스포츠브라"는 유지
    "브래지어", "팬티", "속옷", "언더웨어", "underwear",
    "빵브라", "노와이어브라", "스포츠브라",
    "삼각팬티", "사각팬티", "드로즈",

    # ==================== 건강기능식품 (중국 수입금지) ====================
    "건기식", "건강기능식품", "영양제", "보충제", "서플리먼트", "supplement",
    "프로틴", "protein", "유청단백", "탄수화물보충제", "게이너", "carb",
    "비타민", "vitamin", "오메가3", "유산균", "프로바이오틱스",
    "콜라겐", "글루코사민", "밀크씨슬", "크레아틴", "bcaa", "아미노산",
    "뉴트라바이오", "nutrabio", "옵티멈", "optimum", "머슬팜", "bsn",
}

# 안전 컨텍스트 키워드 (이 키워드가 있으면 위험 키워드 무시)
# 시뮬레이션 결과 반영: 와인랙, 사탕자판기, 초등책상 등 오탐 방지
SAFE_CONTEXT_KEYWORDS = {
    # 가구/수납
    '랙', '선반', '거치대', '홀더', '스탠드', '받침대', '받침',
    '보관함', '수납함', '정리함', '케이스', '박스', '바구니',
    '가구', '테이블', '책상', '의자', '서랍', '캐비넷',

    # 컵/용기류 (와인잔, 맥주잔 등)
    '잔', '컵', '글라스', '텀블러', '머그', '고블렛',
    '트레이', '접시', '그릇', '용기', '볼', '플레이트',

    # 주방/조리도구
    '오프너', '따개', '병따개', '코르크',
    '쿨러', '아이스박스', '보냉', '아이스버킷',
    '디스펜서', '자판기', '보틀',
    '주방', '키친', '조리', '요리', '베이킹',

    # 인테리어/장식
    '인테리어', '장식', '데코', '소품', '디자인',
    '조명', '램프', '무드등', '캔들',

    # 기계/도구
    '기계', '머신', '장치', '기기', '도구', '툴',
    '세척기', '청소기', '분쇄기', '믹서',

    # 학용품/사무용품 (초등, 유치원 오탐 방지)
    '책꽂이', '필통', '연필꽂이', '문구',

    # 스포츠/레저 (킥보드 등 오탐 방지)
    '보호대', '헬멧', '안전장비',

    # 건설/공구 (바이브레이터 등 오탐 방지)
    '콘크리트', '건설', '공구', '시멘트', '진동기', '다짐', '건축',
    '철근', '거푸집', '레미콘', '공사', '현장',

    # 반려동물 (카시트, 유모차 등 오탐 방지)
    '강아지', '애견', '반려견', '펫', 'pet', '반려동물', '고양이', '애완',

    # 연료/기계 (디젤 브랜드 오탐 방지)
    '오일', '펌프', '엔진', '연료', '경유', '기름', '주유', '필터',
    '분사', '노즐', '발전기', '보일러', 'oil', 'pump', 'engine', 'fuel',

    # 패턴/스타일 (버버리, 폴로 등 오탐 방지)
    '체크', '패턴', '무늬', '원단', '천', '셔츠', '카라',

    # 식품/디저트 (몽블랑 케이크 등 오탐 방지)
    '케이크', '디저트', '케익', '빵', '베이커리',
}

# 키워드별 안전 컨텍스트 매핑
# 특정 위험 키워드가 이 컨텍스트와 함께 있으면 → 정상
# 예: "바이브레이터" + "콘크리트" → 건설 공구이므로 정상
# 예: "카시트" + "강아지" → 반려동물용이므로 정상
KEYWORD_SAFE_CONTEXT_MAP = {
    # 성인 키워드 → 공구/산업 컨텍스트
    '바이브레이터': {'콘크리트', '건설', '공구', '시멘트', '진동기', '다짐', '건축', '철근'},
    '진동기': {'콘크리트', '건설', '공구', '시멘트', '마사지', '안마', '건강'},

    # 성인 키워드 → 안전 컨텍스트 없음 (항상 위험)
    '딜도': set(),

    # 아동용품 키워드 → 반려동물/노인/기기 컨텍스트
    '카시트': {'강아지', '애견', '반려견', '펫', 'pet', '반려동물', '고양이', '애완', '중형견', '대형견'},
    '유모차': {'강아지', '애견', '반려견', '펫', 'pet', '반려동물', '고양이', '애완'},
    '젖병': {'강아지', '애견', '반려견', '펫', 'pet', '반려동물', '고양이', '애완', '새끼', '소독', '살균', '피딩'},
    '보행기': {'노인', '할머니', '할아버지', '어르신', '환자', '재활', '워커', '요양', '걸음마'},  # 아기 걸음마 제외
    '이유식': {'제조기', '메이커', '블렌더', '믹서', '두유', '콩물', '건강',
               '저울', '바리스타', '커피', '전자저울', '주방저울', '계량'},  # 이유식 제조기, 바리스타 저울 OK
    '유아용': {'악기', '피아노', '실로폰', '마림바', '건반', '교구', '세발자전거', '자전거'},  # 유아용 악기/교구는 OK

    # ========== 브랜드 키워드 (일반 단어로도 사용되는 경우) ==========
    # "디젤 오일펌프" → 경유 관련 → 정상
    # "디젤 청바지" → DIESEL 브랜드 → 위험 (가품)
    '디젤': {'오일', '펌프', '엔진', '연료', '경유', '기름', '주유', '필터', '분사', '노즐', '발전기', '보일러'},
    'diesel': {'oil', 'pump', 'engine', 'fuel', 'filter', 'injection', 'generator'},

    # "폴로 셔츠" → 폴로 스타일 → 정상 (카라 있는 셔츠 스타일)
    '폴로': {'셔츠', '티셔츠', '카라', '반팔', '긴팔', '니트', '스타일'},

    # "몽블랑 케이크" → 디저트 → 정상
    '몽블랑': {'케이크', '디저트', '케익', '빵', '베이커리', '산', '등산'},

    # "샤넬 염색" → 염색 기법 → 정상
    '샤넬': {'염색', '옴브레', '헤어', '미용'},

    # "버버리 체크" → 체크무늬 패턴 → 정상
    '버버리': {'체크', '패턴', '무늬', '원단', '천'},

    # ========== 금지 키워드 → 안전 컨텍스트 ==========
    # "에어건 송풍기" → 청소용 → 정상
    '에어건': {'송풍기', '송풍', '블로워', '브로워', '청소', '먼지제거', '세차', '낙엽', '무선', '충전식'},

    # "샴푸베드" → 미용실 기구 → 정상
    '샴푸': {'베드', '침대', '미용실', '헤어샵', '세면대', '샴푸대'},

    # "화장품 수납" → 수납가구 → 정상
    '화장품': {'수납', '보관', '정리', '케이스', '파우치', '가방', '트롤리', '화장대', '콘솔'},

    # "전기히터 부품" → 수리용 부품 → 정상
    '전기히터': {'부품', '교체', '수리', '부속', '리미터', '지지대', '브래킷', '바퀴'},

    # "전동휠체어" → 의료기기 → 정상 (전동휠과 구분)
    '전동휠': {'휠체어', '의자', '장애인', '노인', '환자'},

    # "코르셋 보정속옷" → 일반 속옷 → 정상
    # "중세 코르셋 드레스" → 의상/코스튬 → 정상
    '코르셋': {'보정', '거들', '속옷', '압박', '허리', '복대', '웨이스트', '다이어트', '뱃살', '똥배',
               '중세', '드레스', '의상', '빅토리아', '르네상스', '무대', '무대의상', '공연', '파티', '웨딩'},

    # "보정속옷", "기능성 속옷" → 일반 의류 → 정상 (섹시/란제리 제외)
    '속옷': {'보정', '거들', '웨이스트', '복대', '압박', '쉐이퍼', '니퍼', '힙업', '뱃살', '똥배',
             '기능성', '발열', '보온', '쿨링', '흡한', '땀', '스포츠', '운동', '등산', '골프',
             '남성', '남자', '트렁크', '사각', '삼각', '드로즈'},

    # ========== PPT 기반 추가 안전 컨텍스트 (2026-01-15) ==========

    # "냉매 충전기" → OK (PPT 슬라이드 20)
    '냉매': {'충전기', '충전', '게이지', '매니폴드', '호스'},

    # "마사지기", "보호대" → OK (PPT 슬라이드 34: 단순 마사지기, 보호대는 OK)
    # 단, "통증완화", "디스크완화" 키워드 있으면 위험
    '마사지기': {'안마', '마사지', '진동', '지압', '릴렉스', '피로', '근육'},
    '보호대': {'손목', '발목', '무릎', '팔꿈치', '어깨', '등', '허리'},

    # "재떨이", "담배케이스" → OK (PPT 슬라이드 24)
    '담배': {'재떨이', '케이스', '보관함'},

    # "칼" → 주방/공예/산업용품 컨텍스트 (PPT 슬라이드 5)
    # 오탐 수정: 채칼, 구두칼, 재단칼, 칼국수, 칼라 등
    '칼': {'주방', '요리', '과일', '채소', '빵칼', '피자커터', '도마', '칼갈이', '칼꽂이',
           '채칼', '슬라이서', '구두', '주걱', '재단', '커팅기', '절단기', '커터',
           '칼국수', '국수', '칼라', '컬러', '무채', '만능채', '원단', '섬유'},
    '나이프': {'버터', '치즈', '스테이크', '피자', '테이블', '주방', '커트러리'},

    # "레이저" → 공구/산업용 장비는 안전 (레이저포인터, 레이저제모기는 금지)
    '레이저': {'프린터', '복합기', '각인기', '마킹기', '커팅기', '용접기', '용접',
               '레벨기', '레벨', '줄자', '측정기', '거리측정', '수평', '공구'},

    # "가스통" → 운반/거치 장비
    '가스통': {'운반기', '카트', '핸드카', '거치대', '받침대', '트롤리'},

    # "접착제" → 공예/DIY 용도 (PPT 슬라이드 26)
    '접착제': {'공예', 'DIY', '수공예', '미니어처', '모형', '프라모델'},
    '본드': {'공예', 'DIY', '수공예', '목공', '종이'},

    # "배터리" → 소형/교체용 (PPT 슬라이드 27)
    '배터리': {'AA', 'AAA', '건전지', '교체용', '리모컨', '시계'},

    # "타카" → 스테이플러 유형 (PPT 슬라이드 2: 타카건은 위험, 일반 스테이플러는 OK)
    '타카': {'스테이플', '제본', '사무용'},

    # "그물" → 스포츠/인테리어 용도 (PPT 슬라이드 16)
    # 오탐 수정: 의자그물, 탁구그물망 등
    '그물': {'배구', '축구', '골대', '테니스', '배드민턴', '해먹', '인테리어', '정리망',
             '의자', '그네', '천장', '탁구', '수집망', '가림막'},

    # "덫" → 비유적 사용
    '덫': {'게임', '보드게임', '퍼즐'},

    # ========== 시뮬레이션 오탐 기반 추가 (2026-01-15, 2026-01-16 업데이트) ==========

    # "소음기" → 환기/덕트/오토바이/머플러/히터 부품 (총기 소음기 아님)
    '소음기': {'덕트', '환기', '흡음', '배관', '에어컨', '환풍기', '머플러', '배기', '오토바이', '실린더', '밸브', '공압',
               '히터', '무시동히터', '경유히터', '온풍관', '차량', '부품', '화물차'},

    # "원석" → 보석수집/표본/연벼루/팔찌
    '원석': {'정원', '조경', '정원석', '조경석', '화단', '표본', '광물', '컬렉션', '팬던트', '팔찌',
             '보관함', '정리함', '디스플레이', '트레이', '연벼루', '벼루', '서예'},

    # "페인트" → 도배/스프레이건/분사기/에어리스/도장기/차량도색/마킹/작업대/녹제거/셀프
    '페인트': {'롤러', '붓', '도배', '벽지', '리폼', '판금', '필름', '썬팅', '믹서', '교반기',
               '무페인트', '친환경', '원목', '의자', '가구', '램프', '경화', '레진', 'UV',
               '스프레이건', '분사기', '에어리스', '도장기', '뿜칠', '작업복', '멜빵', '정비복',
               '팬톤', '컬러칩', '색상표', '캔', '빈캔', '드럼통', '양철통', '후끼', '브러쉬',
               '차량', '도색', '마킹', '주차선', '스프레이', '자동차', '바디', '보수',
               '돌림판', '작업대', '회전', '용접', '건조랙', '건조대',
               '녹제거', '녹방지', '방청', '셀프', '수성', '철판', '곰팡이', '벽칠', '누수'},

    # "흙" → 정원/청소/체/포크/수중펌프/도자기
    '흙': {'정원', '화단', '테두리', '엣지', '털이', '브러시', '먼지', '클리너',
           '체', '리들', '메쉬', '선별', '받이', '트럭', '커버', '가드', '매트',
           '포크', '삽', '농기구', '경작', '펌프', '배수', '양수', '슬러지',
           '퍼티', '석고', '스크래퍼', '미장', '도자기', '도예', '몰드', '세라믹', '손'},

    # "모래" → 해변/놀이/체/콘홀/샌드아트/색상
    '모래': {'해변', '수영장', '놀이', '스텐', '삽', '굴삭기', '포크레인',
             '콩주머니', '던지기', '게임', '주머니', '체', '거름', '선별',
             '그늘막', '타프', '안전화', '털이', '브러시', '콘홀', '보드',
             '샌드아트', '스크린', 'LED', '연습', '등산화', '양말', '맨발',
             '색', '색상', '베이지', '탄색', '개머리판', '블랙', '그린'},

    # "군용" → 밀리터리 스타일/가방/워치/부츠/모형
    '군용': {'스타일', '패션', '파카', '점퍼', '바람막이', '재킷', '캐주얼',
             '배낭', '백팩', '가방', '대용량', '서바이벌', '전술배낭', '낚시',
             '워치', '스마트워치', '남성용', '울트라', '부츠', '전투화', '작업화', '정글화',
             '깔깔이', '내피', '패딩', '누빔', '헬리콥터', '모형', '다이캐스트', '피규어'},

    # "어망" → 에어망치(공구)만 허용
    # ※ 물고기 잡는 어망/투망/정치망은 위험 (불법어획 가능)
    '어망': {'에어망치', '망치', '함마', '공구', '목공'},

    # "그물" → 스포츠/트렁크/화물/의류/포장재 허용
    # ※ 물고기/새우/고기잡이용 그물은 위험 (불법어획 가능)
    # ※ 농업용(노루망, 닭장), 포장재(과일망) 허용
    '그물': {'배구', '축구', '골대', '테니스', '배드민턴', '해먹', '인테리어', '정리망',
             '의자', '그네', '천장', '탁구', '수집망', '가림막', '스윙', '연습망', '골프',
             '트렁크', '네트', '벤츠', '화물', '크레인', '호이스트', '격자',
             '망사', '메쉬', '시스루', '니트', '티셔츠', '얇은',
             '노루망', '닭장', '양계장', '멧돼지', '나일론', '안전',
             '과일망', '포장재', '포장', '택배', '완충', '보호', '매쉬'},
    # ※ 제외: 선박, 물고기, 뜰채, 새우, 민물, 바다 등 어업 관련

    # "카시트" 추가 컨텍스트 → 성인용 차량시트, 트럭/화물차 시트교체
    '카시트': {'강아지', '애견', '반려견', '펫', 'pet', '반려동물', '고양이', '애완', '중형견', '대형견',
               '회전', '리무진', '카니발', '성인', '차량용', '시트커버',
               '트럭', '화물차', '셀프교체', '좌석', '교체', '자동차시트'},

    # "가스통" → 난로/보관함/거치대/용접/대차
    '가스통': {'운반기', '카트', '핸드카', '거치대', '받침대', '트롤리',
               '난로', '화로', '불멍', '드럼통', '보관함', '안전', '선반',
               '절단기', '용접', '토치', '산소통', '실린더', '대차', '수레',
               '히터', '가열', '보온'},

    # "칼" → 추가 컨텍스트 (믹서칼,면도칼갈이,횟칼연마,조피칼,전정가위,염화칼슘,알칼리,와인칼,차칼,장난감칼)
    '칼': {'주방', '요리', '과일', '채소', '빵칼', '피자커터', '도마', '칼갈이', '칼꽂이',
           '채칼', '슬라이서', '구두', '주걱', '재단', '커팅기', '절단기', '커터',
           '칼국수', '국수', '칼라', '컬러', '무채', '만능채', '원단', '섬유',
           '믹서기', '믹서', '블렌더', '면도', '숫돌', '연마', '샤프너', '횟칼', '회칼',
           '조경', '묘목', '필링', '전정', '가위', '충전식', '서각', '조각도', '조각기',
           '염화칼슘', '살포기', '파종', '알칼리', '산성', '필터', '여과기',
           '와인', '오프너', '코르크', '병따개', '소믈리에', '와인오프너',
           '차칼', '다도', '보이차', '찻잎', '티나이프', '장난감', '방패', '칼날'},

    # "목발" → 발판/나무발판/원목발판 (의료기기 아님)
    '목발': {'발판', '나무', '원목', '싱크대', '계단', '디딤대', '스텝', '사다리', '욕실'},

    # ========== 시뮬레이션 AI 검증 오탐 수정 (2026-01-16) ==========

    # "시스루" → 패션/메쉬/댄스 컨텍스트 (성인용품 아님)
    '시스루': {'패션', '메쉬', '망사', '니트', '원피스', '드레스', '블라우스', '레이스', '탑', '가디건',
               '시스루탑', '시스루원피스', '시스루니트', '쉬폰', '쉬어',
               '라틴', '댄스', '댄스복', '상의', '긴팔', '스포츠'},

    # "교정기" → 자동차 판금/휀다, 골프, 발목 컨텍스트 (치아교정기/자세교정기 아님)
    '교정기': {'휀다', '펜다', '판금', '자동차', '차량', '바디', '덴트', '복원', '수리', '범퍼',
               '골프', '스윙', '연습', '어프로치', '퍼팅', '실내', '가정용',
               '발목', '손목', '무릎', '보조기', '보호대', '족부', '근막염'},

    # "스텐트" → 텐트 오타 컨텍스트 (의료용 스텐트 아님)
    '스텐트': {'텐트', '빙어', '낚시', '캠핑', '얼음', '원터치', '큐브'},

    # "너클" → 오토바이 핸들가드 컨텍스트 (너클 무기 아님)
    '너클': {'핸들가드', '핸들', '오토바이', '바이크', '스쿠터', '가드', '프로텍터', '윈드스크린'},

    # ========== 브랜드 키워드 → 안전 컨텍스트 없음 (항상 위험) ==========
    # 이 브랜드들은 제품 유형과 일치하는 일반 단어가 상품명에 있어도 위험
    # 예: "케이스티파이 케이스" → 케이스 브랜드이므로 당연히 '케이스' 단어 포함
    # 예: "스탠리 텀블러" → 텀블러 브랜드이므로 당연히 '텀블러' 단어 포함
    '케이스티파이': set(),
    'casetify': set(),
    '스탠리': set(),
    'stanley': set(),
    '예티': set(),
    'yeti': set(),
    '하이드로플라스크': set(),
    '리모와': set(),
    'rimowa': set(),
    # 블랙독, 네이처하이크는 중국 브랜드 - 지재권 문제 없어서 제거
}

# ==================== 캐릭터/브랜드 위험 키워드 ====================
# PPT 슬라이드 9,10,11,12,13,15,22,23,35,36 참조
# 캐릭터 상품, 브랜드 상품은 지재권 위험이 높음

# 캐릭터 관련 (PPT 슬라이드 9)
CHARACTER_KEYWORDS = {
    '디즈니', '마블', '픽사', '포켓몬', '피카츄',
    '산리오', '헬로키티', '시나모롤', '쿠로미', '마이멜로디',
    '짱구', '뽀로로', '타요', '핑크퐁', '아기상어',
    '원피스', '나루토', '귀멸의칼날', '주술회전', '스파이패밀리',
    '미키마우스', '미니마우스', '도날드덕', '곰돌이푸',
    '스폰지밥', '패트릭', '미니언즈', '슈퍼마리오',
    '짱구는못말려', '도라에몽', '앙팡맨', '호빵맨',
    # 게임 IP (블리자드, 닌텐도 등)
    '스타크래프트', 'starcraft', '저그', '프로토스', '테란',
    '워크래프트', 'warcraft', '월드오브워크래프트', 'wow',
    '디아블로', 'diablo', '오버워치', 'overwatch',
    '블리자드', 'blizzard',
    '젤다', '젤다의전설',  # 닌텐도 (링크 제거 - 오탐)
    '마인크래프트', 'minecraft',
    '리그오브레전드', 'lol',  # '롤' 제거 - 트롤리, 롤러 등 오탐
    # 중국 게임 IP
    '원신', 'genshin', '붕괴', '명일방주', '아크나이츠',
    # 해리포터 (워너브라더스 지재권)
    '해리포터', 'harrypotter', '호그와트', 'hogwarts', '그리핀도르', '슬리데린', '후플푸프', '래번클로',
    # 코스프레 (캐릭터 지재권 침해)
    '코스프레', 'cosplay', '코스튬',
}

# 연예인/방송 관련 키워드 (PPT 슬라이드 35 - 퍼블리시티권 침해)
# 상품명에 연예인 이름, TV/유튜브 채널 이름 사용 금지
CELEBRITY_KEYWORDS = {
    # TV 프로그램 (예시)
    '나혼자산다', '나혼산', '전참시', '전지적참견시점',
    '신서유기', '삼시세끼', '윤식당', '강식당', '백종원',
    '런닝맨', '무한도전', '놀면뭐하니', '유퀴즈', '유재석',
    '폭삭속았수다', '애순이',  # PPT 예시

    # 유튜버/인플루언서 (예시)
    '빠니보틀', '쯔양', '침착맨', '풍월량', '우왁굳',
    '이사배', '회사원에이', '포니', '홍진경',

    # 아이돌/연예인 (주요)
    'BTS', '방탄소년단', '블랙핑크', 'blackpink',
    '아이유', 'iu', '뉴진스', 'newjeans',
}

# ==================== 카테고리별 검수 설정 ====================
# 검수 레벨: "strict" (엄격-AI확인), "normal" (보통-프로그램), "skip" (검수제외)

# 위험 카테고리 (기본: 엄격 검수)
# - 지재권 침해 위험 (패션, 패션잡화)
# - 판매금지 품목 (유아용품, 의료기기)
# - 인증 필요 품목 (가전, 생활가전)
DEFAULT_CATEGORY_RISK_SETTINGS = {
    # ==================== 엄격 검수 (strict) ====================
    # PPT "지재권 위험 리스트" 기반 업데이트 (2026-01-15)

    # 패션 - 지재권(가품) 위험 높음 (PPT 슬라이드 10)
    '패션의류': 'strict',
    '남성의류': 'strict',
    '여성의류': 'strict',
    '패션잡화': 'strict',
    '가방': 'strict',
    '지갑': 'strict',
    '시계': 'strict',
    '주얼리': 'strict',
    '액세서리': 'strict',
    '신발': 'strict',
    '스니커즈': 'strict',

    # 유아/아동 - 판매금지 품목 (PPT 슬라이드 1)
    '유아동': 'strict',
    '유아용품': 'strict',
    '출산/육아': 'strict',
    '아동복': 'strict',
    '유아': 'strict',
    '아동': 'strict',
    '키즈': 'strict',

    # 의료/건강 - 규제 품목 (PPT 슬라이드 34)
    '의료기기': 'strict',
    '건강식품': 'strict',
    '건강용품': 'strict',
    '의료': 'strict',

    # 식품 - 수입 규제
    '식품': 'strict',

    # 화장품 - 규제 품목
    '화장품': 'strict',
    '뷰티': 'strict',
    '스킨케어': 'strict',

    # 스포츠용품 - 브랜드 위험 높음 (PPT 슬라이드 36)
    '스포츠의류': 'strict',
    '스포츠잡화': 'strict',
    '골프': 'strict',
    '승마': 'strict',

    # 낚시 - 브랜드 위험 (PPT 슬라이드 4)
    '낚시': 'strict',
    '낚시용품': 'strict',

    # 캠핑 - 브랜드 위험 (PPT 슬라이드 15)
    '캠핑': 'strict',
    '캠핑용품': 'strict',

    # 디지털/휴대폰 관련 (PPT 슬라이드 11,12,14,31)
    '폰케이스': 'strict',
    '휴대폰케이스': 'strict',
    '게이밍': 'strict',
    '게이밍기어': 'strict',
    '중고폰': 'strict',
    '태블릿': 'strict',

    # 캐리어/여행가방 (PPT 슬라이드 23)
    '캐리어': 'strict',
    '여행가방': 'strict',

    # 텀블러 (PPT 슬라이드 13)
    '텀블러': 'strict',

    # 이불/쿠션 커버 (PPT 슬라이드 30 - 명품 패턴)
    '이불': 'strict',
    '침구': 'strict',
    '쿠션커버': 'strict',

    # 캐릭터 상품 (PPT 슬라이드 9)
    '캐릭터': 'strict',
    '인형': 'strict',
    '피규어': 'strict',

    # 안전관련 (PPT 슬라이드 18)
    '안전용품': 'strict',
    '구명용품': 'strict',

    # ==================== 보통 검수 (normal) ====================

    # 가전 - KC인증 필요
    '가전': 'normal',
    '생활가전': 'normal',
    '주방가전': 'normal',
    '계절가전': 'normal',

    # 일반 생활용품
    '생활용품': 'normal',
    '주방용품': 'normal',
    '인테리어': 'normal',
    '수납': 'normal',
    '사무용품': 'normal',
    '문구': 'normal',

    # 디지털 (일반)
    '디지털': 'normal',
    '컴퓨터': 'normal',
    '모바일': 'normal',
    '카메라': 'normal',

    # 스포츠/레저 (일반)
    '스포츠': 'normal',
    '레저': 'normal',
    '아웃도어': 'normal',

    # 자동차/공구
    '자동차용품': 'normal',
    '공구': 'normal',
    '산업용품': 'normal',

    # 가구 - 디자인권 주의 (PPT 슬라이드 33)
    '가구': 'normal',
    '의자': 'normal',
}

# 카테고리 검수 설정 파일
CATEGORY_RISK_FILE = "category_risk_settings.json"


def load_category_risk_settings() -> dict:
    """카테고리별 검수 설정 로드"""
    if os.path.exists(CATEGORY_RISK_FILE):
        try:
            with open(CATEGORY_RISK_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            pass
    return DEFAULT_CATEGORY_RISK_SETTINGS.copy()


def save_category_risk_settings(settings: dict) -> bool:
    """카테고리별 검수 설정 저장"""
    try:
        with open(CATEGORY_RISK_FILE, 'w', encoding='utf-8') as f:
            json.dump(settings, f, ensure_ascii=False, indent=2)
        return True
    except:
        return False


def get_category_risk_level(category_name: str, settings: dict = None) -> str:
    """카테고리의 검수 레벨 반환 (strict/normal/skip)"""
    if settings is None:
        settings = load_category_risk_settings()

    # 정확한 매칭
    if category_name in settings:
        return settings[category_name]

    # 부분 매칭 (카테고리명에 키워드 포함)
    category_lower = category_name.lower()
    for key, level in settings.items():
        if key.lower() in category_lower or category_lower in key.lower():
            return level

    # 기본값: 보통 검수
    return 'normal'


# 브랜드 키워드 (가품 위험) - 항상 위험 (일반 단어로 안 쓰임)
# PPT 슬라이드 10,11,12,13,15,22,23,36 기반 대폭 업데이트 (2026-01-15)
BRAND_KEYWORDS = {
    # ==================== 명품 브랜드 ====================
    '구찌', 'gucci', '루이비통', 'louisvuitton', 'lv백', '에르메스', 'hermes',
    '프라다', 'prada', '발렌시아가', 'balenciaga', '보테가베네타', 'bottegaveneta',
    '셀린느', 'celine', '디올', 'dior', '펜디', 'fendi',
    '입생로랑', 'ysl', '생로랑', '지방시', 'givenchy',
    '발렌티노', 'valentino', '톰브라운', 'thombrowne',
    '막스마라', 'maxmara', '몽클레어', 'moncler', '캐나다구스', 'canadagoose',

    # ==================== 시계 브랜드 ====================
    '롤렉스', 'rolex', '까르띠에', 'cartier', '파텍필립', 'patekphilippe',
    '오데마피게', 'audemarspiguet', '파네라이', 'panerai',
    '오메가', 'omega', '태그호이어', 'tagheuer', '브라이틀링', 'breitling',

    # ==================== 스포츠/스트릿 브랜드 (가품 많음) ====================
    '스투시', 'stussy', '슈프림', 'supreme', '오프화이트', 'offwhite',
    '나이키', 'nike', '아디다스', 'adidas', '퓨마', 'puma',
    '뉴발란스', 'newbalance', '아식스', 'asics', '리복', 'reebok',
    '노스페이스', 'northface', '파타고니아', 'patagonia', '아크테릭스', 'arcteryx',

    # ==================== 폰케이스 브랜드 (PPT 슬라이드 11) ====================
    '케이스티파이', 'casetify',

    # ==================== 게이밍 주변기기 브랜드 (PPT 슬라이드 12) ====================
    '로지텍', 'logitech', '레이저', 'razer', '스틸시리즈', 'steelseries',
    '커세어', 'corsair', '하이퍼엑스', 'hyperx',

    # ==================== 텀블러 브랜드 (PPT 슬라이드 13) ====================
    '스탠리', 'stanley', '예티', 'yeti', '하이드로플라스크', 'hydroflask',
    '스타벅스', 'starbucks', '써모스', 'thermos', '조약돌',

    # ==================== 캠핑 브랜드 (PPT 슬라이드 15) ====================
    # 블랙독, 네이처하이크는 중국 브랜드 - 제거
    '힐레베르그', 'hilleberg',
    '스노우피크', 'snowpeak', 'msr', '빅아그네스', 'bigagnes',
    '헬리녹스', 'helinox', '코베아', 'kovea',

    # ==================== 캐리어 브랜드 (PPT 슬라이드 23) ====================
    '리모와', 'rimowa', '투미', 'tumi', '샘소나이트', 'samsonite',

    # ==================== 낚시 브랜드 (PPT 슬라이드 4) ====================
    '시마노', 'shimano', '다이와', 'daiwa', '아부가르시아', 'abugarcia',

    # ==================== 골프 브랜드 (PPT 슬라이드 36) ====================
    '타이틀리스트', 'titleist', '캘러웨이', 'callaway', '테일러메이드', 'taylormade',
    # '핑' 제거 - "캠핑", "쇼핑" 등에서 오탐 발생
    'ping골프', '코브라골프', '스릭슨', 'srixon',

    # ==================== 호환 상품 관련 키워드 (PPT 슬라이드 22) ====================
    # "~호환", "~용" 키워드가 브랜드명과 함께 있으면 위험
    '애플호환', '삼성호환', '다이슨호환', '아이폰호환', '갤럭시호환',

    # ==================== IT 브랜드 (지재권 위험) ====================
    # 애플
    '맥북', 'macbook', '아이맥', 'imac', '아이폰', 'iphone',
    '아이패드', 'ipad', '에어팟', 'airpods', '애플워치', 'applewatch',
    # 삼성
    '갤럭시', 'galaxy', '갤럭시북', 'galaxybook',
    # 다이슨
    '다이슨', 'dyson',
    # 소니
    '플레이스테이션', 'playstation', 'ps5',
    # 마이크로소프트
    '엑스박스', 'xbox', '서피스', 'surface',
    # 오디오 브랜드
    '샥즈', '샥스', 'shokz', '오픈런', 'openrun',  # 골전도 이어폰
    '에어팟', 'airpods', '버즈', 'buds',  # 무선이어폰
}

# ==================== 옵션 미끼 키워드 (uploader) ====================

# 기본 미끼 키워드 (타오바오 판매자 미끼 패턴)
# ※ 주의: 실제 상품명/옵션명에 자주 나오는 단어는 제외해야 함
DEFAULT_BAIT_KEYWORDS = [
    # 맞춤/주문제작 관련 (확실한 미끼)
    '맞춤제작', '주문제작', '주문 제작', '제작문의', '별도제작', '특별제작',
    '커스텀주문', '맞춤주문',
    '사용자정의', '사용자 정의', '커스터마이징',

    # 부품/액세서리 미끼 - 더 구체적으로
    '부품만', '부속품만', '교체용부품', '리필용',
    '충전기만', '어댑터만', '선만', '젠더만',
    # '액세서리' 제거 - 실제 액세서리 상품과 혼동

    # 배송 관련 (실제 옵션에 사용될 수 있음)
    '배송비별도', '추가배송비',
    '공장직송', '공장 직송', '스팟배송', '스팟 배송', '송장가능',

    # 중국어 미끼 (타오바오) - 확실한 것만
    '定制', '定做', '订制', '订做',  # 맞춤제작
    '联系客服', '咨询客服',  # 문의/상담
    '邮费', '运费',  # 배송비
    '样品',  # 샘플

    # 추가: 번역 오류/이상한 옵션
    '품절', '재고없음', '단종', '판매종료',
    '사진참고', '이미지참고', '상세참고',

    # 안내문/홍보문구 (옵션이 아닌 텍스트)
    '약속드립니다', '진심으로', '감사합니다', '환영합니다',
    '공지입니다', '안내드립니다', '알려드립니다', '드립니다',
    '꼭읽어주세요', '읽어주세요', '확인바랍니다', '부탁드립니다',
    '링크참고', '상세페이지', '상세확인', '페이지참고',

    # 판매자 홍보/마케팅 문구
    '팔로우', '즐겨찾기', '구독', '좋아요', '추천인',
    '할인쿠폰', '쿠폰받기', '혜택받기', '이벤트참여',
    '리뷰이벤트', '포토리뷰', '베스트리뷰',
]

# 미끼 예외 키워드 (이 키워드가 있으면 미끼로 판단하지 않음)
# "안내서 포함", "설명서 제공" 등 실제 구성품을 나타내는 경우
# 검증 결과 (2026-01-14): "배터리 2개만" = 미끼, "본품 + 배터리 2개" = 정상
BAIT_EXCEPTION_KEYWORDS = [
    # 구성품 표시 (정상 옵션)
    '포함', '제공', '동봉', '증정', '세트', '구성', '추가', '함께',
    '포함된', '제공되는', '동봉되는', '구성된',
    '있는', '있음', '갖춘',
    # 중국어: 포함
    '付', '含', '套装', '配',
    # 수량 표현 (본품과 함께 제공)
    '1개', '2개', '3개', '4개', '5개',
    '개입', '개세트', '쌍',
]

# 문맥 의존 키워드 (단독 사용 시에만 미끼로 판정)
# 검증 결과: "케이블 정리함" = 정상, "케이블만" = 미끼
CONTEXT_DEPENDENT_BAIT_KEYWORDS = [
    '케이블', '충전기', '어댑터', '부품', '액세서리',
    '배터리', '거치대', '브라켓', '커넥터', '젠더',
]

# 단독 사용 패턴 (이 패턴이 있으면 미끼)
BAIT_ONLY_PATTERNS = [
    '만', '용', '전용', '별도', '단품', '개별',
    '만구매', '만판매', '만주문', '추가구매',
]

# 강력 미끼 키워드 (예외 체크 없이 바로 미끼 처리)
# 가격이 정상이어도, 공통키워드여도 무조건 제외
STRONG_BAIT_KEYWORDS = {
    # 품절/재고 관련 (절대 미끼)
    '품절', '재고없음', '재고 없음', '단종', '판매종료', '판매 종료',
    '매진', '일시품절', '품절임박',
    # 환불/반품 관련 (절대 미끼)
    '환불', '반품', '교환불가', '교환 불가', '환불불가', '환불 불가',
    # 사은품/증정 관련 (절대 미끼)
    '사은품', '증정품', '덤', '서비스', '무료증정',
    # 예약/선주문 (절대 미끼)
    '예약', '선주문', '선 주문', '예약주문',
    # 계약/예약금 관련 (절대 미끼)
    '계약금', '선금', '예약금', '보증금', '착수금', '정금', '잔금', '추가금', '차액결제',
    # 안내문/홍보 (절대 미끼)
    '약속드립니다', '진심으로', '감사합니다', '환영합니다',
    '공지입니다', '안내드립니다', '알려드립니다',
    '꼭읽어주세요', '읽어주세요', '확인바랍니다', '부탁드립니다',
    # 판매자 홍보/마케팅 (절대 미끼)
    '팔로우', '즐겨찾기', '구독하시면', '추천인',
    '쿠폰받기', '혜택받기', '이벤트참여',
    '리뷰이벤트', '포토리뷰', '베스트리뷰',
    # 마케팅 문구 (절대 미끼)
    '한정제조', '한정 제조', '손해보는', '손해판매', '인민보험', '환불보장',
    '제조사손해', '제조사 손해', '한정판매', '영수증확인', '영수증 확인',
    # 샘플/테스트 (절대 미끼)
    '샘플용', '테스트용', '무료체험', '체험판', '시험용',
    # 옵션 선택 유도 (절대 미끼)
    '옵션선택필수', '필수선택', '선택필수', '색상선택필수', '사이즈선택필수',
    '옵션문의', '선택안함', '해당없음', '선택하세요',
    # 설치/조립비용 (절대 미끼)
    '설치비별도', '조립비별도', '출장비별도',
    # 가격 미끼 (절대 미끼)
    '1원', '10원', '100원', '0원', '쿠폰전용', '적립금전용',
    # 안내/비고 (절대 미끼)
    '필독사항', '확인필수', '주의사항필독', '공지사항',
    '배송안내', '교환안내', '반품안내', '주의안내', '필독안내',
    '참고사항', '안내사항', '유의사항',
    # 문의/상담 (절대 미끼)
    '고객센터문의', '연락주세요', '전화주세요', '카톡문의', '채팅문의',
    '문의요망', '문의필수', '먼저문의', '상담후구매', '문의후결제', '상담필수',
}


# ==================== 키워드 파일 관리 ====================

def load_banned_words() -> Tuple[Set[str], dict]:
    """금지단어 파일 로드 (여러 JSON 형태 지원)"""
    if os.path.exists(BANNED_WORDS_FILE):
        try:
            with open(BANNED_WORDS_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                all_words = set()

                # Case 1: 단순 리스트 형태
                if isinstance(data, list):
                    all_words.update(data)
                    return all_words, {"words": data}

                # Case 2: {"words": [...]} 형태
                if isinstance(data, dict) and 'words' in data:
                    words = data.get('words', [])
                    if isinstance(words, list):
                        all_words.update(words)

                # Case 3: {"categories": {...}} 형태
                if isinstance(data, dict) and 'categories' in data:
                    categories = data.get('categories', {})
                    if isinstance(categories, dict):
                        for cat_data in categories.values():
                            if isinstance(cat_data, dict):
                                words = cat_data.get('words', [])
                                if isinstance(words, list):
                                    all_words.update(words)
                            elif isinstance(cat_data, list):
                                all_words.update(cat_data)

                # Case 4: AI 감지 단어
                if isinstance(data, dict) and 'ai_detected' in data:
                    ai_detected = data.get('ai_detected', {})
                    if isinstance(ai_detected, dict):
                        approved = ai_detected.get('approved', [])
                        if isinstance(approved, list):
                            all_words.update(approved)

                return all_words, data
        except Exception as e:
            print(f"금지단어 로드 실패: {e}")
    return set(), {}


def save_banned_words(words: Set[str], data: dict = None) -> bool:
    """금지단어 파일 저장"""
    try:
        if data is None:
            data = {"words": sorted(list(words))}
        else:
            data["words"] = sorted(list(words))
        with open(BANNED_WORDS_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        print(f"금지단어 저장 실패: {e}")
        return False


def load_excluded_words() -> Set[str]:
    """예외단어 파일 로드 (탐지 제외)"""
    if os.path.exists(EXCLUDED_WORDS_FILE):
        try:
            with open(EXCLUDED_WORDS_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                return set(data.get('words', []))
        except Exception as e:
            print(f"예외단어 로드 실패: {e}")
    return set()


def save_excluded_words(words: Set[str]) -> bool:
    """예외단어 파일 저장"""
    try:
        data = {'words': sorted(list(words))}
        with open(EXCLUDED_WORDS_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        print(f"예외단어 저장 실패: {e}")
        return False


def load_remove_words() -> Set[str]:
    """제거단어 파일 로드 (상품명에서 무조건 삭제)"""
    if os.path.exists(REMOVE_WORDS_FILE):
        try:
            with open(REMOVE_WORDS_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                return set(data.get('words', []))
        except Exception as e:
            print(f"제거단어 로드 실패: {e}")
    return set()


def save_remove_words(words: Set[str]) -> bool:
    """제거단어 파일 저장"""
    try:
        data = {'words': sorted(list(words))}
        with open(REMOVE_WORDS_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        print(f"제거단어 저장 실패: {e}")
        return False


def load_bait_keywords() -> List[str]:
    """미끼옵션 키워드 로드"""
    if os.path.exists(BAIT_KEYWORDS_FILE):
        try:
            with open(BAIT_KEYWORDS_FILE, 'r', encoding='utf-8') as f:
                data = json.load(f)
                return data.get('keywords', DEFAULT_BAIT_KEYWORDS[:])
        except Exception as e:
            print(f"미끼키워드 로드 실패: {e}")
    return DEFAULT_BAIT_KEYWORDS[:]


def save_bait_keywords(keywords: List[str]) -> bool:
    """미끼옵션 키워드 저장"""
    try:
        data = {'keywords': keywords}
        with open(BAIT_KEYWORDS_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        print(f"미끼키워드 저장 실패: {e}")
        return False


# ==================== Google Sheets 동기화 ====================

def sync_from_google_sheets(sheet_url: str, log_callback=None) -> dict:
    """
    Google Sheets에서 금지단어/예외단어/제거단어 동기화

    시트 형식 (bulsaja_words 시트):
    - A열: 금지단어
    - B열: 예외단어 (탐지 제외)
    - C열: 제거단어
    - D열: 미끼키워드 (옵션 필터용)

    Returns: {'banned': [...], 'excluded': [...], 'remove': [...], 'bait': [...], 'success': bool, 'message': str}
    """
    result = {'banned': [], 'excluded': [], 'remove': [], 'bait': [], 'success': False, 'message': ''}

    try:
        import gspread
        from google.oauth2.service_account import Credentials
    except ImportError:
        result['message'] = "gspread 또는 google-auth 패키지가 필요합니다"
        if log_callback:
            log_callback(f"❌ {result['message']}")
        return result

    try:
        # 서비스 계정 JSON 파일 찾기
        service_account_file = None
        for filename in os.listdir('.'):
            if filename.endswith('.json') and 'auto-smartstore' in filename.lower():
                service_account_file = filename
                break

        if not service_account_file:
            possible_files = ['auto-smartstore-update-61c3a948c45c.json', 'service_account.json', 'credentials.json']
            for pf in possible_files:
                if os.path.exists(pf):
                    service_account_file = pf
                    break

        if not service_account_file:
            result['message'] = "서비스 계정 JSON 파일을 찾을 수 없습니다"
            if log_callback:
                log_callback(f"❌ {result['message']}")
            return result

        if log_callback:
            log_callback(f"📥 시트 연결 중... ({service_account_file})")

        # Google Sheets API 인증
        scopes = [
            'https://www.googleapis.com/auth/spreadsheets',
            'https://www.googleapis.com/auth/drive'
        ]
        creds = Credentials.from_service_account_file(service_account_file, scopes=scopes)
        gc = gspread.authorize(creds)

        # Sheet ID 추출
        if '/d/' in sheet_url:
            sheet_id = sheet_url.split('/d/')[1].split('/')[0]
        else:
            sheet_id = sheet_url

        spreadsheet = gc.open_by_key(sheet_id)

        # bulsaja_words 시트 찾기
        try:
            worksheet = spreadsheet.worksheet('bulsaja_words')
        except:
            worksheet = spreadsheet.sheet1

        all_values = worksheet.get_all_values()

        banned_words = []
        excluded_words = []
        remove_words = []
        bait_keywords = []

        for row_num, row in enumerate(all_values):
            if row_num == 0:  # 헤더 스킵
                continue

            # A열: 금지단어
            if len(row) >= 1 and row[0].strip():
                banned_words.append(row[0].strip())

            # B열: 예외단어
            if len(row) >= 2 and row[1].strip():
                excluded_words.append(row[1].strip())

            # C열: 제거단어
            if len(row) >= 3 and row[2].strip():
                remove_words.append(row[2].strip())

            # D열: 미끼키워드
            if len(row) >= 4 and row[3].strip():
                bait_keywords.append(row[3].strip())

        result['banned'] = banned_words
        result['excluded'] = excluded_words
        result['remove'] = remove_words
        result['bait'] = bait_keywords
        result['success'] = True
        result['message'] = f"금지 {len(banned_words)}개, 예외 {len(excluded_words)}개, 제거 {len(remove_words)}개, 미끼 {len(bait_keywords)}개"

        if log_callback:
            log_callback(f"✅ {result['message']}")

    except Exception as e:
        result['message'] = f"동기화 실패: {e}"
        if log_callback:
            log_callback(f"❌ {result['message']}")

    return result


# ==================== 썸네일 매칭 유틸 ====================

def extract_image_id(url: str) -> str:
    """이미지 URL에서 고유 ID 추출 (파일명)"""
    if not url:
        return ""
    try:
        parsed = urlparse(url)
        path = parsed.path
        filename = path.split('/')[-1] if '/' in path else path
        name_part = filename.rsplit('.', 1)[0] if '.' in filename else filename
        return name_part
    except:
        return url


def match_thumbnail_to_sku(thumbnails: List[str], skus: List[Dict]) -> Optional[int]:
    """
    대표 썸네일과 매칭되는 SKU 인덱스 찾기

    Args:
        thumbnails: uploadThumbnails 배열 (첫 번째가 대표 이미지)
        skus: uploadSkus 배열

    Returns:
        매칭되는 SKU 인덱스 또는 None
    """
    if not thumbnails or not skus:
        return None

    # 대표 썸네일 ID 추출 (첫 번째 이미지)
    main_thumb_id = extract_image_id(thumbnails[0])
    if not main_thumb_id:
        return None

    # 각 SKU의 이미지와 비교
    for idx, sku in enumerate(skus):
        sku_image_url = sku.get('urlRef') or sku.get('image') or ''
        if not sku_image_url:
            continue

        sku_image_id = extract_image_id(sku_image_url)

        # 이미지 ID가 포함되어 있으면 매칭
        if main_thumb_id in sku_image_id or sku_image_id in main_thumb_id:
            return idx

    # 2차 시도: alicdn 이미지끼리 파일명 비교
    main_thumb_url = thumbnails[0].lower()
    for idx, sku in enumerate(skus):
        sku_image_url = (sku.get('urlRef') or sku.get('image') or '').lower()
        if not sku_image_url:
            continue
        if 'alicdn.com' in main_thumb_url and 'alicdn.com' in sku_image_url:
            main_file = main_thumb_url.split('/')[-1]
            sku_file = sku_image_url.split('/')[-1]
            if main_file == sku_file:
                return idx

    # 3차 시도: 불사자 CDN 경로의 상품 ID 비교
    # 썸네일: https://cdn.bulsaja.com/.../U01KEXGVBGHXQ9FPKZGX2NT18RK/...
    # SKU: https://cdn.bulsaja.com/.../U01KEXGVBGHXQ9FPKZGX2.../...
    if 'cdn.bulsaja.com' in main_thumb_url:
        # 썸네일에서 상품 ID 추출 (U01K로 시작하는 부분)
        main_parts = main_thumb_url.split('/')
        main_product_id = None
        for part in main_parts:
            if part.startswith('u01k'):
                main_product_id = part
                break

        if main_product_id:
            for idx, sku in enumerate(skus):
                sku_url = (sku.get('urlRef') or '').lower()
                if main_product_id in sku_url:
                    return idx

    return None


# ==================== 상품명 기반 대표옵션 매칭 ====================

def match_option_by_product_name(product_name: str, skus: List[Dict]) -> Tuple[Optional[int], float, str]:
    """
    상품명을 분석하여 가장 적합한 대표옵션 찾기

    타오바오 상품명 패턴:
    - "검정색 가죽 소파 3인용" → 색상(검정), 재질(가죽), 크기(3인용)
    - "화이트 L사이즈 면 티셔츠" → 색상(화이트), 사이즈(L), 재질(면)

    Args:
        product_name: 상품명
        skus: SKU 배열

    Returns:
        (매칭된 SKU 인덱스, 매칭률, 매칭 이유) 또는 (None, 0, '')
    """
    if not product_name or not skus:
        return None, 0.0, ''

    product_name_lower = product_name.lower()

    # 색상 키워드 (한국어/영어/중국어)
    COLOR_KEYWORDS = {
        # 한국어
        '검정', '검은', '블랙', '흑색', '까만',
        '흰색', '하얀', '화이트', '백색',
        '빨강', '빨간', '레드', '적색',
        '파랑', '파란', '블루', '청색', '네이비',
        '노랑', '노란', '옐로우', '황색',
        '초록', '그린', '녹색',
        '분홍', '핑크',
        '보라', '퍼플', '바이올렛',
        '주황', '오렌지',
        '갈색', '브라운', '카키',
        '회색', '그레이', '실버', '은색',
        '금색', '골드',
        '베이지', '아이보리', '크림',
        # 영어
        'black', 'white', 'red', 'blue', 'navy', 'yellow', 'green',
        'pink', 'purple', 'orange', 'brown', 'gray', 'grey', 'silver', 'gold',
        'beige', 'ivory', 'cream', 'khaki',
        # 중국어
        '黑', '白', '红', '蓝', '黄', '绿', '粉', '紫', '橙', '棕', '灰', '银', '金',
    }

    # 사이즈 키워드
    SIZE_KEYWORDS = {
        'xs', 's', 'm', 'l', 'xl', 'xxl', 'xxxl',
        '소', '중', '대', '특대',
        'small', 'medium', 'large',
        '1인용', '2인용', '3인용', '4인용',
        '싱글', '더블', '퀸', '킹',
    }

    # 상품명에서 키워드 추출
    found_colors = []
    found_sizes = []

    for color in COLOR_KEYWORDS:
        if color in product_name_lower:
            found_colors.append(color)

    for size in SIZE_KEYWORDS:
        if size in product_name_lower:
            found_sizes.append(size)

    # 키워드가 없으면 매칭 불가
    if not found_colors and not found_sizes:
        return None, 0.0, '키워드없음'

    # 각 SKU와 매칭률 계산
    best_idx = None
    best_score = 0.0
    best_reason = ''

    for idx, sku in enumerate(skus):
        option_text = (sku.get('text_ko', '') or sku.get('text', '')).lower()
        if not option_text:
            continue

        score = 0.0
        matched_keywords = []

        # 색상 매칭 (가중치 높음)
        for color in found_colors:
            if color in option_text:
                score += 2.0
                matched_keywords.append(f'색상:{color}')

        # 사이즈 매칭
        for size in found_sizes:
            if size in option_text:
                score += 1.5
                matched_keywords.append(f'사이즈:{size}')

        # 점수가 높으면 갱신
        if score > best_score:
            best_score = score
            best_idx = idx
            best_reason = ', '.join(matched_keywords)

    # 최소 매칭 점수 기준 (색상 1개 이상 매칭)
    if best_score >= 2.0:
        # 매칭률 계산: 찾은 키워드 수 대비 매칭된 비율
        total_keywords = len(found_colors) + len(found_sizes)
        match_rate = best_score / (total_keywords * 2.0) if total_keywords > 0 else 0
        return best_idx, min(match_rate, 1.0), best_reason

    return None, 0.0, ''


def select_main_option(product_name: str, skus: List[Dict]) -> Tuple[int, str]:
    """
    대표옵션 선택 (이미지 우선 → 상품명 매칭 → 첫 번째 옵션)

    우선순위:
    1. 상품명 기반 매칭 (이미지 있는 옵션 우선)
    2. 이미지가 있는 첫 번째 옵션
    3. 첫 번째 옵션

    Args:
        product_name: 상품명
        skus: 미끼 필터링된 SKU 배열

    Returns:
        (선택된 SKU 인덱스, 선택 방법)
    """
    if not skus:
        return 0, '옵션없음'

    def has_image(sku: Dict) -> bool:
        """SKU에 이미지가 있는지 확인"""
        return bool(sku.get('urlRef') or sku.get('image') or sku.get('img'))

    # 1. 상품명 기반 매칭 시도
    matched_idx, match_rate, reason = match_option_by_product_name(product_name, skus)

    if matched_idx is not None and match_rate >= 0.3:
        # 매칭된 옵션에 이미지가 있으면 그대로 사용
        if has_image(skus[matched_idx]):
            return matched_idx, f'상품명매칭({reason})'
        # 이미지 없으면 이미지 있는 옵션 중에서 찾기
        for idx, sku in enumerate(skus):
            if has_image(sku):
                return idx, '이미지우선'

    # 2. 이미지가 있는 첫 번째 옵션
    for idx, sku in enumerate(skus):
        if has_image(sku):
            return idx, '이미지우선'

    # 3. 폴백: 첫 번째 옵션
    return 0, '첫번째옵션'


# ==================== 상품 검사 유틸 ====================

def check_product_safety(title: str, excluded_words: Set[str] = None,
                         use_ai_fallback: bool = False, ai_config: dict = None,
                         check_level: str = 'normal', category_name: str = None) -> dict:
    """
    상품명에서 위험 키워드 검사 (문맥 기반 판단 + AI 폴백)

    로직:
    1. 위험 키워드 탐지
    2. 해당 키워드에 대한 안전 컨텍스트가 있는지 확인
       - KEYWORD_SAFE_CONTEXT_MAP에 정의된 키워드별 컨텍스트 우선 확인
       - 없으면 일반 SAFE_CONTEXT_KEYWORDS로 확인
    3. 안전 컨텍스트가 있으면 → 해당 위험 키워드만 무시
    4. 안전 컨텍스트 없으면 → 위험 상품
    5. (옵션) AI 폴백: 프로그램 판단 불가 시 AI에게 문의

    예시:
    - "콘크리트 바이브레이터" → 바이브레이터의 안전 컨텍스트(콘크리트) 있음 → 정상
    - "성인용품 바이브레이터" → 안전 컨텍스트 없음 → 위험

    Args:
        title: 상품명
        excluded_words: 제외할 키워드 (이미 검증된 키워드)
        use_ai_fallback: True면 판단 불가 시 AI에게 문의 (deprecated, use check_level)
        ai_config: AI 설정 (None이면 파일에서 로드)
        check_level: 검수 레벨
            - 'strict': 엄격 (AI 확인 필수, 안전 컨텍스트 있어도 AI 검증)
            - 'normal': 보통 (프로그램 자동 판단, 안전 컨텍스트 적용)
            - 'skip': 검수 제외 (항상 안전)
        category_name: 카테고리명 (자동으로 check_level 결정에 사용)

    Returns:
        {
            'is_safe': bool,
            'categories': {
                'adult': [...],
                'medical': [...],
                'child': [...],
                'prohibited': [...]
            },
            'all_found': [],
            'safe_context_found': [],  # 안전 컨텍스트로 판단된 키워드
            'ai_judgment': [],  # AI 판단 결과 (strict 모드일 때)
            'check_level': str  # 사용된 검수 레벨
        }
    """
    if excluded_words is None:
        excluded_words = set()

    # 카테고리명으로 검수 레벨 자동 결정 (명시적 지정이 없을 때)
    if category_name and check_level == 'normal':
        check_level = get_category_risk_level(category_name)

    # use_ai_fallback 호환성 (deprecated)
    if use_ai_fallback and check_level == 'normal':
        check_level = 'strict'

    result = {
        'is_safe': True,
        'categories': {
            'adult': [],
            'medical': [],
            'child': [],
            'prohibited': [],
            'brand': []  # 브랜드 (가품 위험)
        },
        'all_found': [],
        'safe_context_found': [],
        'ai_judgment': [],
        'check_level': check_level  # 사용된 검수 레벨 기록
    }

    # skip 모드: 검수 제외 (항상 안전)
    if check_level == 'skip':
        return result

    title_lower = title.lower()

    # 상품명에서 발견된 모든 안전 컨텍스트 키워드 수집
    found_safe_contexts = set()
    for safe_kw in SAFE_CONTEXT_KEYWORDS:
        if safe_kw in title_lower:
            found_safe_contexts.add(safe_kw)

    # AI 판단이 필요한 키워드 수집 (프로그램으로 판단 불가)
    keywords_need_ai = []

    def check_keyword(keyword: str, category_list: list):
        """키워드 체크 (문맥 판단 포함)"""
        if keyword in excluded_words or keyword.lower() in excluded_words:
            return

        keyword_lower = keyword.lower()
        if keyword_lower not in title_lower:
            return

        # 위험 키워드 발견됨 → 안전 컨텍스트 확인

        # 1. 키워드별 전용 안전 컨텍스트 확인
        keyword_specific_contexts = KEYWORD_SAFE_CONTEXT_MAP.get(keyword_lower, None)

        if keyword_specific_contexts is not None:
            # 키워드별 전용 컨텍스트가 정의되어 있음
            if len(keyword_specific_contexts) == 0:
                # 빈 set = 안전 컨텍스트 없음 (항상 위험)
                category_list.append(keyword)
                return

            # 전용 컨텍스트 중 하나라도 상품명에 있는지 직접 확인
            matched_contexts = []
            for ctx in keyword_specific_contexts:
                if ctx.lower() in title_lower:
                    matched_contexts.append(ctx)

            if matched_contexts:
                # 안전 컨텍스트 매칭됨
                if check_level == 'strict':
                    # 엄격 모드: 안전 컨텍스트 있어도 AI 검증 필요
                    keywords_need_ai.append((keyword, f"컨텍스트:{','.join(matched_contexts[:2])}"))
                else:
                    # 보통 모드: 안전 컨텍스트로 정상 처리
                    result['safe_context_found'].append(f"{keyword}→{','.join(matched_contexts[:2])}")
                return
            else:
                # 전용 컨텍스트에 매칭 안됨 → AI 판단 필요 또는 위험
                if check_level == 'strict':
                    keywords_need_ai.append((keyword, "컨텍스트없음"))
                else:
                    category_list.append(keyword)
                return

        # 2. 일반 안전 컨텍스트 확인 (키워드별 정의 없을 때)
        if found_safe_contexts:
            # 일반 안전 컨텍스트가 있음
            if check_level == 'strict':
                # 엄격 모드: AI 검증 필요
                keywords_need_ai.append((keyword, f"일반컨텍스트:{','.join(list(found_safe_contexts)[:2])}"))
            else:
                # 보통 모드: 정상으로 처리
                result['safe_context_found'].append(f"{keyword}→{','.join(list(found_safe_contexts)[:2])}")
        else:
            # 안전 컨텍스트 없음 → 위험
            category_list.append(keyword)

    # 각 카테고리별 키워드 체크
    for keyword in ADULT_KEYWORDS:
        check_keyword(keyword, result['categories']['adult'])

    for keyword in MEDICAL_KEYWORDS:
        check_keyword(keyword, result['categories']['medical'])

    for keyword in CHILD_KEYWORDS:
        check_keyword(keyword, result['categories']['child'])

    for keyword in PROHIBITED_KEYWORDS:
        check_keyword(keyword, result['categories']['prohibited'])

    # 브랜드 키워드 체크 (가품 위험)
    for keyword in BRAND_KEYWORDS:
        check_keyword(keyword, result['categories']['brand'])

    # 캐릭터 키워드 체크 (PPT 슬라이드 9: 지재권 위험)
    for keyword in CHARACTER_KEYWORDS:
        if keyword.lower() in title_lower and keyword not in excluded_words:
            result['categories']['brand'].append(f"캐릭터:{keyword}")

    # 연예인/방송 키워드 체크 (PPT 슬라이드 35: 퍼블리시티권 침해)
    for keyword in CELEBRITY_KEYWORDS:
        if keyword.lower() in title_lower and keyword not in excluded_words:
            result['categories']['prohibited'].append(f"연예인/방송:{keyword}")

    # AI 검증: strict 모드 또는 use_ai_fallback일 때 AI에게 문의
    if (check_level == 'strict' or use_ai_fallback) and keywords_need_ai:
        for item in keywords_need_ai:
            # 새 형식: (keyword, context_info) 또는 이전 형식: keyword만
            if isinstance(item, tuple):
                keyword, context_info = item
            else:
                keyword = item
                context_info = ""

            is_safe, reason = check_product_safety_with_ai(title, keyword, ai_config)
            result['ai_judgment'].append(f"{keyword}({context_info}): {reason}")

            # AI 호출 실패 시 (reason에 "실패" 포함)
            if 'API 키' in reason or '실패' in reason or '오류' in reason:
                # 컨텍스트가 있었으면 정상 처리, 없으면 위험 처리
                if '컨텍스트:' in context_info:
                    result['safe_context_found'].append(f"{keyword}(AI미사용)→{context_info}")
                else:
                    # 컨텍스트 없음 → 위험
                    if keyword.lower() in [k.lower() for k in ADULT_KEYWORDS]:
                        result['categories']['adult'].append(keyword)
                    elif keyword.lower() in [k.lower() for k in CHILD_KEYWORDS]:
                        result['categories']['child'].append(keyword)
                    elif keyword.lower() in [k.lower() for k in BRAND_KEYWORDS]:
                        result['categories']['brand'].append(keyword)
                    else:
                        result['categories']['prohibited'].append(keyword)
            elif not is_safe:
                # AI가 위험으로 판단 → 카테고리에 추가
                if keyword.lower() in [k.lower() for k in ADULT_KEYWORDS]:
                    result['categories']['adult'].append(f"{keyword}(AI)")
                elif keyword.lower() in [k.lower() for k in CHILD_KEYWORDS]:
                    result['categories']['child'].append(f"{keyword}(AI)")
                elif keyword.lower() in [k.lower() for k in BRAND_KEYWORDS]:
                    result['categories']['brand'].append(f"{keyword}(AI)")
                else:
                    result['categories']['prohibited'].append(f"{keyword}(AI)")
            else:
                # AI가 안전으로 판단
                result['safe_context_found'].append(f"{keyword}(AI)→{reason[:30]}")

    # 결과 집계
    for cat_keywords in result['categories'].values():
        result['all_found'].extend(cat_keywords)

    result['is_safe'] = len(result['all_found']) == 0

    return result


def _is_context_dependent_bait(keyword: str, text: str) -> bool:
    """
    문맥 의존 키워드의 미끼 여부 판단

    검증 결과 (2026-01-14):
    - "케이블 정리함" → 정상 (제품명)
    - "케이블만" → 미끼 (부속품만)
    - "케이블 포함" → 정상 (구성품)
    - "충전기와 배터리 2개가 포함된" → 정상
    """
    text_lower = text.lower()
    keyword_lower = keyword.lower()

    # 1. 예외 키워드가 있으면 정상 (포함, 세트, 구성 등)
    for exc in BAIT_EXCEPTION_KEYWORDS:
        if exc in text_lower:
            return False  # 미끼 아님

    # 2. "~만", "~용", "~전용" 패턴이면 미끼
    for pattern in BAIT_ONLY_PATTERNS:
        # 키워드 바로 뒤에 "만" 등이 오는지 확인
        check_pattern = f"{keyword_lower}{pattern}"
        if check_pattern in text_lower:
            return True  # 미끼

    # 3. 키워드가 옵션명 끝에 있으면 미끼 가능성 높음
    # 예: "USB 케이블" (끝) vs "케이블 정리함" (중간)
    text_stripped = text_lower.strip()
    if text_stripped.endswith(keyword_lower):
        # 단, 앞에 수량이나 색상이 있으면 정상
        # 예: "블랙 케이블", "2M 케이블"
        words_before = text_stripped[:-len(keyword_lower)].strip().split()
        if words_before:
            last_word = words_before[-1]
            # 색상/길이/수량 표현이면 정상
            if any(c in last_word for c in ['색', 'm', 'cm', '개', '미터']):
                return False
        return True  # 미끼

    # 4. 기본적으로 정상으로 판단 (오탐 방지)
    return False


def filter_bait_options(skus: List[Dict], bait_keywords: List[str],
                        price_threshold_ratio: float = 0.15,
                        min_price_cny: float = 3.0) -> Tuple[List[Dict], List[Dict]]:
    """
    미끼옵션 필터링 (키워드 + 가격 + 문맥 기반)

    개선사항 (2026-01-14 검증 결과 반영):
    - 문맥 의존 키워드: "케이블만" = 미끼, "케이블 포함" = 정상
    - 예외 키워드 확장: 포함, 추가, 세트, 구성 등

    Args:
        skus: SKU 배열
        bait_keywords: 미끼 키워드 리스트
        price_threshold_ratio: 중간가 대비 이 비율 이하면 미끼 (기본 15%)
        min_price_cny: 절대 최저가 기준 (기본 3위안 이하면 미끼)

    Returns:
        (유효 SKU 리스트, 미끼 SKU 리스트)
    """
    valid_skus = []
    bait_skus = []

    # [v1.4] 미끼 키워드 빈도+가격 분석 - 다수 옵션에 공통으로 포함되고 정상가격이면 상품 특성으로 간주
    keyword_skus = {}  # 키워드별 매칭된 SKU 리스트
    for kw in bait_keywords:
        kw_lower = kw.lower()
        matching = []
        for sku in skus:
            text = sku.get('text', '') or sku.get('_text', '')
            text_ko = sku.get('text_ko', '')
            combined = f"{text} {text_ko}".lower()
            if kw_lower in combined:
                matching.append(sku)
        if matching:
            keyword_skus[kw] = matching

    # 전체 옵션 평균 가격
    all_prices = [sku.get('_origin_price', 0) or sku.get('price', 0) for sku in skus]
    all_prices = [p for p in all_prices if p > 0]
    avg_price = sum(all_prices) / len(all_prices) if all_prices else 0

    # 2개 이상 옵션에 포함된 키워드는 가격 검증
    excluded_common_keywords = set()
    for kw, matching_skus in keyword_skus.items():
        if len(matching_skus) >= 2:  # 최소 2개 이상 옵션에 포함
            kw_prices = [sku.get('_origin_price', 0) or sku.get('price', 0) for sku in matching_skus]
            kw_prices = [p for p in kw_prices if p > 0]
            kw_avg = sum(kw_prices) / len(kw_prices) if kw_prices else 0
            # 전체 평균의 50% 이상이면 미끼 가격 아님 → 키워드 필터링 제외
            if avg_price > 0 and kw_avg >= avg_price * 0.5:
                excluded_common_keywords.add(kw.lower())

    # 1. 가격 기반 미끼 판단을 위한 중간값(median) 계산
    prices = []
    for sku in skus:
        price = sku.get('_origin_price', 0) or sku.get('price', 0)
        if price and price > 0:
            prices.append(price)

    if prices:
        sorted_prices = sorted(prices)
        n = len(sorted_prices)
        if n % 2 == 0:
            median_price = (sorted_prices[n//2 - 1] + sorted_prices[n//2]) / 2
        else:
            median_price = sorted_prices[n//2]
        min_in_list = sorted_prices[0]
        max_in_list = sorted_prices[-1]
    else:
        median_price = 0
        min_in_list = 0
        max_in_list = 0

    # 가격 편차가 큰 경우에만 상대 기준 적용 (최대/최소 비율이 5배 이상)
    price_variance_high = max_in_list > min_in_list * 5 if min_in_list > 0 else False
    price_threshold = median_price * price_threshold_ratio if median_price > 0 else min_price_cny

    for sku in skus:
        text = sku.get('text', '') or sku.get('_text', '')
        text_ko = sku.get('text_ko', '')
        combined_text = f"{text} {text_ko}".lower()
        price = sku.get('_origin_price', 0) or sku.get('price', 0)

        is_bait = False
        bait_reason = ""

        # 2. 가격 기반 미끼 체크 (먼저 실행 - 가격 탐지 효과 측정용)
        if price > 0:
            # 절대 기준: 3위안 이하 (배송비/샘플 미끼)
            if price < min_price_cny:
                is_bait = True
                bait_reason = f"[저가필터]:{price:.1f}CNY"
            # 상대 기준: 가격 편차가 클 때만 적용 (중간가의 15% 이하)
            elif price_variance_high and median_price > 0 and price < price_threshold:
                is_bait = True
                bait_reason = f"[저가필터]:{price:.1f}CNY<{median_price:.0f}의15%"

        # 3. 키워드 기반 미끼 체크 (가격으로 안 걸렸어도 키워드 체크)
        if not is_bait:
            for keyword in bait_keywords:
                keyword_lower = keyword.lower()
                if keyword_lower in combined_text:
                    # [v1.4] 공통 키워드는 건너뛰기 (2개+ 옵션에 포함 + 정상가격)
                    if keyword_lower in excluded_common_keywords:
                        continue

                    # 3-0. 강력 미끼 키워드 (예외 체크 없이 바로 미끼)
                    if keyword in STRONG_BAIT_KEYWORDS:
                        is_bait = True
                        bait_reason = f"키워드:{keyword}(강력)"
                        break

                    # 3-1. 문맥 의존 키워드인지 확인
                    if keyword in CONTEXT_DEPENDENT_BAIT_KEYWORDS:
                        # 문맥 기반 판단
                        if _is_context_dependent_bait(keyword, combined_text):
                            is_bait = True
                            bait_reason = f"키워드:{keyword}(단독)"
                            break
                        else:
                            continue  # 문맥상 정상이면 다음 키워드 체크

                    # 3-2. 일반 키워드: 예외 키워드 확인
                    has_exception = any(exc in combined_text for exc in BAIT_EXCEPTION_KEYWORDS)
                    if has_exception:
                        continue  # 예외 키워드 있으면 다음 미끼 키워드 체크

                    is_bait = True
                    bait_reason = f"키워드:{keyword}"
                    break

        if is_bait:
            sku['_bait_keyword'] = bait_reason
            bait_skus.append(sku)
        else:
            valid_skus.append(sku)

    return valid_skus, bait_skus


# ==================== 불사자 API 클라이언트 ====================

# 마켓 ID 매핑
MARKET_IDS = {
    "스마트스토어": 10200,
    "11번가": 10201,
    "G마켓/옥션": 10202,
    "쿠팡": 14516,
}

# 마켓 타입 매핑
MARKET_TYPES = {
    "스마트스토어": "SMARTSTORE",
    "11번가": "ST11",
    "G마켓/옥션": "ESM",
    "쿠팡": "COUPANG",
}


class BulsajaAPIClient:
    """불사자 API 클라이언트"""
    BASE_URL = "https://api.bulsaja.com/api"

    def __init__(self, access_token: str = "", refresh_token: str = ""):
        self.access_token = access_token
        self.refresh_token = refresh_token
        self.session = requests.Session()
        # 사용자의 실제 마켓 ID 캐시 (동적으로 로드)
        self._user_market_ids: Dict[str, int] = {}
        if access_token:
            self._setup_session()

    def _setup_session(self):
        self.session.headers.update({
            'accept': 'application/json, text/plain, */*',
            'accept-language': 'ko,en-US;q=0.9,en;q=0.8',
            'accesstoken': self.access_token,
            'refreshtoken': self.refresh_token,
            'content-type': 'application/json',
            'origin': 'https://www.bulsaja.com',
            'referer': 'https://www.bulsaja.com/',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })

    def update_tokens(self, access_token: str, refresh_token: str):
        self.access_token = access_token
        self.refresh_token = refresh_token
        self._setup_session()

    def test_connection(self) -> Tuple[bool, str, int]:
        """연결 테스트"""
        try:
            products, total = self.get_products(0, 1)
            return True, f"연결 성공 (총 {total}개 상품)", total
        except Exception as e:
            return False, str(e), 0

    def get_products(self, start_row: int = 0, end_row: int = 100, filter_model: Dict = None) -> Tuple[List[Dict], int]:
        """상품 목록 조회"""
        url = f"{self.BASE_URL}/manage/list/serverside"
        payload = {
            "request": {
                "startRow": start_row,
                "endRow": end_row,
                "sortModel": [],
                "filterModel": filter_model or {}
            }
        }
        response = self.session.post(url, json=payload)
        response.raise_for_status()
        data = response.json()
        products = data.get('rowData', [])
        total_count = data.get('lastRow', len(products))
        return products, total_count

    def get_products_by_group(self, group_name: str, start: int = 0, limit: int = 1000,
                              status_filters: List[str] = None,
                              exclude_tag: str = None) -> Tuple[List[Dict], int]:
        """그룹별 상품 조회

        status_filters: 상품 상태 필터 (예: ["0", "1", "2"])
            - API에서 그룹 필터만 적용하고, 상태 필터는 결과에서 직접 필터링
        exclude_tag: 제외할 태그명 (예: "업로드실패")
            - 해당 태그가 있는 상품 제외
        """
        # 기본 필터 모델 구성
        base_filter = {}
        if group_name:
            base_filter["marketGroupName"] = {
                "filterType": "text",
                "type": "equals",
                "filter": group_name
            }

        # 상태 필터 OR 조건 적용 (bulsaja_api_structure.md 참조)
        if status_filters:
            # 숫자 상태값만 필터링 (API는 숫자만 지원: 0,1,2,3)
            numeric_statuses = [s for s in status_filters if s.isdigit()]
            if numeric_statuses:
                if len(numeric_statuses) == 1:
                    # 단일 상태: 기본 형식
                    base_filter["status"] = {
                        "filterType": "text",
                        "type": "equals",
                        "filter": numeric_statuses[0]
                    }
                else:
                    # 다중 상태: OR 조건 사용
                    conditions = []
                    for status in numeric_statuses:
                        conditions.append({
                            "filterType": "text",
                            "type": "equals",
                            "filter": status
                        })
                    base_filter["status"] = {
                        "filterType": "text",
                        "operator": "OR",
                        "conditions": conditions
                    }

        # 태그 제외 필터 (업로드실패 태그 건너뛰기)
        if exclude_tag:
            base_filter["groupFile"] = {
                "filterType": "text",
                "type": "notContains",
                "filter": exclude_tag
            }

        products, total = self.get_products(start, start + limit, base_filter)
        return products, total

    def get_product_detail(self, product_id: str) -> Dict:
        """상품 상세 정보 조회"""
        url = f"{self.BASE_URL}/manage/sourcing-product/{product_id}"
        response = self.session.get(url)
        response.raise_for_status()
        result = response.json()
        if 'data' in result:
            return result['data']
        return result

    def get_upload_fields(self, product_id: str) -> Dict:
        """업로드 필드 정보 조회 (고시정보 등 포함)"""
        url = f"{self.BASE_URL}/sourcing/uploadfields/{product_id}"
        try:
            response = self.session.get(url)
            response.raise_for_status()
            result = response.json()
            # payload 안에 실제 데이터가 있는 경우
            if 'payload' in result:
                return result['payload']
            return result
        except Exception as e:
            # fallback: get_product_detail 사용
            return {}

    def update_product_fields(self, product_id: str, product_data: Dict) -> Tuple[bool, str]:
        """상품 정보 업데이트"""
        url = f"{self.BASE_URL}/sourcing/uploadfields/{product_id}"
        try:
            response = self.session.put(url, json=product_data)
            response.raise_for_status()

            # 응답 내용 확인
            try:
                result = response.json()
                if isinstance(result, dict):
                    if result.get('error') or result.get('errors'):
                        error_msg = result.get('error') or result.get('errors') or result.get('message', '')
                        return False, f"API 오류: {str(error_msg)[:100]}"
                    if result.get('success') == False:
                        return False, f"업데이트 실패: {result.get('message', '알 수 없는 오류')[:100]}"
                return True, "성공"
            except:
                return True, "성공 (응답 파싱 불가)"

        except requests.exceptions.HTTPError as e:
            error_detail = ""
            try:
                error_detail = e.response.text[:200]
            except:
                pass
            return False, f"HTTP 오류: {e.response.status_code} - {error_detail}"
        except Exception as e:
            return False, f"예외: {str(e)}"

    def get_market_id(self, market_name: str) -> int:
        """사용자의 실제 마켓 ID 가져오기 (캐시 사용)"""
        # 캐시가 비어있으면 API에서 조회
        if not self._user_market_ids:
            self._user_market_ids = self.get_user_markets()
            if self._user_market_ids:
                print(f"[INFO] 마켓 ID 로드됨: {self._user_market_ids}")

        # 사용자 마켓 ID에서 찾기
        if market_name in self._user_market_ids:
            return self._user_market_ids[market_name]

        # 못 찾으면 기본값 (경고 출력)
        fallback_id = MARKET_IDS.get(market_name, 10200)
        print(f"[WARNING] '{market_name}' 마켓 ID를 찾지 못함. 기본값 {fallback_id} 사용")
        return fallback_id

    def upload_product(self, product_id: str, market_name: str = "스마트스토어") -> Tuple[bool, str]:
        """상품 업로드"""
        # 사용자의 실제 마켓 ID 동적으로 가져오기
        market_id = self.get_market_id(market_name)
        market_type = MARKET_TYPES.get(market_name, "SMARTSTORE")
        url = f"{self.BASE_URL}/market/{market_id}/upload/"
        payload = {
            "productId": product_id,
            "notices": None,
            "preventDuplicateUpload": True,
            "removeDuplicateWords": True,
            "targetMarket": market_type
        }
        try:
            response = self.session.post(url, json=payload)
            response.raise_for_status()

            # 응답 내용 확인
            try:
                result = response.json()
                # 응답에 에러가 있는지 확인
                if isinstance(result, dict):
                    if result.get('error') or result.get('errors'):
                        error_msg = result.get('error') or result.get('errors') or result.get('message', '알 수 없는 오류')
                        return False, f"업로드 실패: {str(error_msg)[:100]}"
                    if result.get('success') == False:
                        return False, f"업로드 실패: {result.get('message', '알 수 없는 오류')[:100]}"
                    # 상태 확인
                    status = result.get('status') or result.get('uploadStatus')
                    if status and status.lower() in ['failed', 'error', 'failure']:
                        return False, f"업로드 실패: {result.get('message', status)[:100]}"
                return True, f"성공 (응답: {str(result)[:50]})"
            except:
                # JSON 파싱 실패시 텍스트로 확인
                text = response.text[:100] if response.text else "응답 없음"
                return True, f"성공 (raw: {text})"

        except requests.exceptions.HTTPError as e:
            error_detail = ""
            try:
                error_detail = e.response.text[:100]
            except:
                pass
            return False, f"{error_detail}"
        except Exception as e:
            return False, str(e)

    def get_market_groups(self) -> List[str]:
        """마켓 그룹 목록 조회 (번호순 정렬)"""
        url = f"{self.BASE_URL}/market/groups/"
        try:
            response = self.session.post(url, json={})
            response.raise_for_status()
            data = response.json()
            if isinstance(data, list):
                names = [g.get('name', '') for g in data if g.get('name')]
                # 그룹명 번호순 정렬 (앞의 숫자 기준)
                def sort_by_number(name):
                    match = re.match(r'^(\d+)', name)
                    return int(match.group(1)) if match else 9999
                return sorted(names, key=sort_by_number)
            return []
        except Exception as e:
            print(f"마켓 그룹 조회 실패: {e}")
            return []

    def get_user_markets(self) -> Dict[str, int]:
        """사용자의 마켓 ID 매핑 조회 (연결된 마켓 목록에서 실제 ID 추출)"""
        url = f"{self.BASE_URL}/market/groups/"
        try:
            response = self.session.post(url, json={})
            response.raise_for_status()
            data = response.json()

            # 디버그: 전체 응답 구조 출력 (첫 번째 그룹)
            if isinstance(data, list) and len(data) > 0:
                first_group = data[0]
                print(f"[DEBUG] /market/groups/ 첫 번째 그룹 키: {list(first_group.keys())}")
                # 마켓 정보가 어디에 있는지 찾기
                for key in first_group.keys():
                    val = first_group.get(key)
                    if isinstance(val, list) and len(val) > 0:
                        print(f"[DEBUG] {key} (list, len={len(val)}): 첫 번째 요소 키 = {list(val[0].keys()) if isinstance(val[0], dict) else val[0]}")
                    elif isinstance(val, dict):
                        print(f"[DEBUG] {key} (dict): 키 = {list(val.keys())}")

            market_ids = {}
            if isinstance(data, list):
                for group in data:
                    # 각 그룹에서 마켓 정보 추출 (여러 필드 시도)
                    markets = group.get('markets', []) or group.get('connectedMarkets', []) or group.get('marketList', [])

                    # 그룹 자체가 마켓 정보를 포함할 수도 있음
                    if not markets and 'marketType' in group:
                        markets = [group]

                    for market in markets:
                        if not isinstance(market, dict):
                            continue
                        market_type = market.get('marketType', '') or market.get('type', '')
                        # ID는 여러 필드명으로 존재할 수 있음
                        market_id = (market.get('id') or market.get('marketId') or
                                    market.get('market_id') or market.get('ID'))
                        if market_type and market_id:
                            # 마켓 타입을 한글 이름으로 변환
                            type_name_map = {
                                'SMARTSTORE': '스마트스토어',
                                'ST11': '11번가',
                                'ESM': 'G마켓/옥션',
                                'COUPANG': '쿠팡',
                            }
                            name = type_name_map.get(market_type, market_type)
                            if name not in market_ids:
                                market_ids[name] = market_id
                                print(f"[DEBUG] 마켓 발견: {name} = {market_id}")

            print(f"[DEBUG] get_user_markets 최종 결과: {market_ids}")
            return market_ids
        except Exception as e:
            print(f"[DEBUG] get_user_markets 오류: {e}")
            import traceback
            traceback.print_exc()
            return {}


def extract_tokens_from_browser(port: int = 9222) -> Tuple[bool, str, str, str]:
    """크롬 디버그 모드에서 토큰 추출"""
    try:
        tabs_url = f"http://127.0.0.1:{port}/json"
        try:
            response = requests.get(tabs_url, timeout=3)
            tabs = response.json()
        except:
            return False, "", "", f"크롬 포트 {port} 연결 실패"

        bulsaja_tab = None
        for tab in tabs:
            if 'bulsaja.com' in tab.get('url', ''):
                bulsaja_tab = tab
                break

        if not bulsaja_tab:
            return False, "", "", "불사자 탭 없음"

        ws_url = bulsaja_tab.get('webSocketDebuggerUrl')
        if not ws_url:
            return False, "", "", "WebSocket URL 없음"

        ws = websocket.create_connection(ws_url, timeout=5)
        cmd = {
            "id": 1,
            "method": "Runtime.evaluate",
            "params": {
                "expression": """
                    (function() {
                        var tokenStr = localStorage.getItem('token');
                        if (tokenStr) {
                            try {
                                var tokenObj = JSON.parse(tokenStr);
                                if (tokenObj.state) {
                                    return JSON.stringify({
                                        accessToken: tokenObj.state.accessToken || '',
                                        refreshToken: tokenObj.state.refreshToken || ''
                                    });
                                }
                            } catch(e) {}
                        }
                        return JSON.stringify({accessToken: '', refreshToken: ''});
                    })()
                """,
                "returnByValue": True
            }
        }
        ws.send(json.dumps(cmd))
        result = json.loads(ws.recv())
        ws.close()

        if 'result' in result and 'result' in result['result']:
            token_data = json.loads(result['result']['result'].get('value', '{}'))
            access_token = token_data.get('accessToken', '')
            refresh_token = token_data.get('refreshToken', '')
            if access_token and refresh_token:
                return True, access_token, refresh_token, ""

        return False, "", "", "토큰 파싱 실패"
    except Exception as e:
        return False, "", "", f"예외: {e}"


# ==================== 다중 AI API 지원 모듈 ====================

# AI 설정 파일
AI_CONFIG_FILE = "ai_config.json"

# 기본 AI 설정
DEFAULT_AI_CONFIG = {
    'provider': 'gemini',  # gemini, claude, openai
    'gemini': {
        'api_key': '',
        'model': 'gemini-2.0-flash'
    },
    'claude': {
        'api_key': '',
        'model': 'claude-3-5-sonnet-20241022'
    },
    'openai': {
        'api_key': '',
        'model': 'gpt-4o-mini'
    }
}


def load_ai_config() -> dict:
    """AI 설정 로드"""
    if os.path.exists(AI_CONFIG_FILE):
        try:
            with open(AI_CONFIG_FILE, 'r', encoding='utf-8') as f:
                config = json.load(f)
                # 기본값 병합
                for key, value in DEFAULT_AI_CONFIG.items():
                    if key not in config:
                        config[key] = value
                    elif isinstance(value, dict):
                        for sub_key, sub_value in value.items():
                            if sub_key not in config[key]:
                                config[key][sub_key] = sub_value
                return config
        except Exception:
            pass
    return DEFAULT_AI_CONFIG.copy()


def save_ai_config(config: dict) -> bool:
    """AI 설정 저장"""
    try:
        with open(AI_CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, ensure_ascii=False, indent=2)
        return True
    except Exception:
        return False


def call_ai_api(prompt: str, config: dict = None, timeout: int = 30) -> Tuple[bool, str, str]:
    """
    다중 AI API 호출 (Gemini / Claude / OpenAI)

    Args:
        prompt: 질문 내용
        config: AI 설정 (None이면 파일에서 로드)
        timeout: 타임아웃 (초)

    Returns:
        (성공여부, 응답텍스트, 에러메시지)
    """
    if config is None:
        config = load_ai_config()

    provider = config.get('provider', 'gemini')

    if provider == 'gemini':
        return _call_gemini(prompt, config.get('gemini', {}), timeout)
    elif provider == 'claude':
        return _call_claude(prompt, config.get('claude', {}), timeout)
    elif provider == 'openai':
        return _call_openai(prompt, config.get('openai', {}), timeout)
    else:
        return False, '', f'지원하지 않는 AI 제공자: {provider}'


def _call_gemini(prompt: str, settings: dict, timeout: int) -> Tuple[bool, str, str]:
    """Gemini API 호출"""
    api_key = settings.get('api_key', '')
    model = settings.get('model', 'gemini-2.0-flash')

    if not api_key:
        return False, '', 'Gemini API 키가 설정되지 않았습니다'

    try:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
        payload = {
            'contents': [{'parts': [{'text': prompt}]}],
            'generationConfig': {
                'temperature': 0.3,
                'maxOutputTokens': 1024,
            }
        }

        response = requests.post(
            f"{url}?key={api_key}",
            headers={'Content-Type': 'application/json'},
            json=payload,
            timeout=timeout
        )

        if response.status_code != 200:
            return False, '', f'Gemini API 오류 ({response.status_code})'

        data = response.json()
        if 'candidates' in data and data['candidates']:
            content = data['candidates'][0].get('content', {})
            parts = content.get('parts', [])
            if parts:
                return True, parts[0].get('text', ''), ''

        return False, '', 'Gemini 응답 파싱 실패'

    except requests.exceptions.Timeout:
        return False, '', f'Gemini API 타임아웃 ({timeout}초)'
    except Exception as e:
        return False, '', f'Gemini API 오류: {e}'


def _call_claude(prompt: str, settings: dict, timeout: int) -> Tuple[bool, str, str]:
    """Claude API 호출"""
    api_key = settings.get('api_key', '')
    model = settings.get('model', 'claude-3-5-sonnet-20241022')

    if not api_key:
        return False, '', 'Claude API 키가 설정되지 않았습니다'

    try:
        url = "https://api.anthropic.com/v1/messages"
        headers = {
            'Content-Type': 'application/json',
            'x-api-key': api_key,
            'anthropic-version': '2023-06-01'
        }
        payload = {
            'model': model,
            'max_tokens': 1024,
            'messages': [
                {'role': 'user', 'content': prompt}
            ]
        }

        response = requests.post(url, headers=headers, json=payload, timeout=timeout)

        if response.status_code != 200:
            return False, '', f'Claude API 오류 ({response.status_code})'

        data = response.json()
        if 'content' in data and data['content']:
            return True, data['content'][0].get('text', ''), ''

        return False, '', 'Claude 응답 파싱 실패'

    except requests.exceptions.Timeout:
        return False, '', f'Claude API 타임아웃 ({timeout}초)'
    except Exception as e:
        return False, '', f'Claude API 오류: {e}'


def _call_openai(prompt: str, settings: dict, timeout: int) -> Tuple[bool, str, str]:
    """OpenAI API 호출"""
    api_key = settings.get('api_key', '')
    model = settings.get('model', 'gpt-4o-mini')

    if not api_key:
        return False, '', 'OpenAI API 키가 설정되지 않았습니다'

    try:
        url = "https://api.openai.com/v1/chat/completions"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            'model': model,
            'max_tokens': 1024,
            'temperature': 0.3,
            'messages': [
                {'role': 'user', 'content': prompt}
            ]
        }

        response = requests.post(url, headers=headers, json=payload, timeout=timeout)

        if response.status_code != 200:
            return False, '', f'OpenAI API 오류 ({response.status_code})'

        data = response.json()
        if 'choices' in data and data['choices']:
            return True, data['choices'][0].get('message', {}).get('content', ''), ''

        return False, '', 'OpenAI 응답 파싱 실패'

    except requests.exceptions.Timeout:
        return False, '', f'OpenAI API 타임아웃 ({timeout}초)'
    except Exception as e:
        return False, '', f'OpenAI API 오류: {e}'


# ==================== AI 기반 상품 안전 판단 ====================

def check_product_safety_with_ai(title: str, dangerous_keyword: str, config: dict = None) -> Tuple[bool, str]:
    """
    AI에게 상품 안전 여부 문의

    프로그램으로 판단이 애매한 경우 (위험 키워드 탐지 but 안전 컨텍스트 불명확)
    AI에게 문의하여 최종 판단

    Args:
        title: 상품명
        dangerous_keyword: 탐지된 위험 키워드
        config: AI 설정

    Returns:
        (안전여부, 판단이유)
    """
    prompt = f"""당신은 한국 구매대행 상품 안전 판별 전문가입니다.

다음 상품명에서 "{dangerous_keyword}" 키워드가 탐지되었습니다.
이 상품이 실제로 위험한 상품인지 판단해주세요.

상품명: {title}
탐지된 키워드: {dangerous_keyword}

판단 기준:
- "바이브레이터" → 콘크리트/건설 관련이면 공구(안전), 성인용품이면 위험
- "카시트" → 강아지/애견 관련이면 반려동물용(안전), 아기용이면 KC인증 필요(위험)
- "진동기" → 마사지/건설 관련이면 안전, 성인용품이면 위험

반드시 다음 형식으로만 답변하세요:
SAFE 또는 DANGER
이유: (한 줄 설명)

예시:
SAFE
이유: 콘크리트 바이브레이터는 건설용 공구입니다."""

    success, response, error = call_ai_api(prompt, config, timeout=15)

    if not success:
        # AI 호출 실패 시 안전하지 않음으로 기본 처리
        return False, f'AI 판단 실패: {error}'

    response_upper = response.upper().strip()

    if 'SAFE' in response_upper.split('\n')[0]:
        # 이유 추출
        reason_match = response.split('이유:')
        reason = reason_match[1].strip() if len(reason_match) > 1 else 'AI 판단: 안전'
        return True, f'AI→안전: {reason[:50]}'
    else:
        reason_match = response.split('이유:')
        reason = reason_match[1].strip() if len(reason_match) > 1 else 'AI 판단: 위험'
        return False, f'AI→위험: {reason[:50]}'


# ==================== Gemini AI 학습 모듈 ====================

# Gemini API 설정 (레거시 호환용, 새 코드는 load_ai_config 사용)
GEMINI_API_KEY = "AIzaSyDvkncM1ecu6R2bKOcLoqHzehmG58vz-Bw"
GEMINI_MODEL = "gemini-2.0-flash"  # 최신 빠른 모델


def analyze_simulation_with_gemini(excel_path: str, log_callback=None) -> dict:
    """
    시뮬레이션 결과 Excel을 Gemini AI로 분석

    Args:
        excel_path: 시뮬레이션 결과 Excel 파일 경로
        log_callback: 로그 출력 함수

    Returns:
        {
            'success': bool,
            'report': str,  # 한페이지 분석 리포트
            'recommendations': {
                'add_bait_keywords': [],  # 추가할 미끼 키워드
                'remove_bait_keywords': [],  # 제거할 미끼 키워드 (오탐)
                'add_exception_keywords': [],  # 추가할 예외 키워드
                'price_threshold_suggestion': float,  # 가격 기준 제안
            },
            'statistics': {
                'total_products': int,
                'bait_detected': int,
                'false_positive_suspected': int,
                'false_negative_suspected': int,
            },
            'error': str
        }
    """
    result = {
        'success': False,
        'report': '',
        'recommendations': {
            'add_bait_keywords': [],
            'remove_bait_keywords': [],
            'add_exception_keywords': [],
            'price_threshold_suggestion': None,
        },
        'statistics': {},
        'error': ''
    }

    try:
        import pandas as pd
    except ImportError:
        result['error'] = "pandas 패키지가 필요합니다: pip install pandas"
        if log_callback:
            log_callback(f"❌ {result['error']}")
        return result

    # 1. Excel 파일 로드
    if log_callback:
        log_callback(f"📂 Excel 파일 로드 중: {excel_path}")

    try:
        df = pd.read_excel(excel_path)
    except Exception as e:
        result['error'] = f"Excel 로드 실패: {e}"
        if log_callback:
            log_callback(f"❌ {result['error']}")
        return result

    if log_callback:
        log_callback(f"✅ {len(df)}개 상품 로드 완료")

    # 2. 분석용 데이터 준비
    analysis_data = _prepare_analysis_data(df)

    if log_callback:
        log_callback(f"📊 분석 데이터 준비 완료")
        log_callback(f"   - 미끼 탐지: {analysis_data['bait_count']}건")
        log_callback(f"   - 의심 오탐: {analysis_data['false_positive_count']}건")

    # 3. Gemini API 호출
    if log_callback:
        log_callback(f"🤖 Gemini AI 분석 요청 중...")

    gemini_result = _call_gemini_api(analysis_data, log_callback)

    if not gemini_result['success']:
        result['error'] = gemini_result['error']
        return result

    # 4. 결과 파싱
    result['success'] = True
    result['report'] = gemini_result['report']
    result['recommendations'] = gemini_result['recommendations']
    result['statistics'] = {
        'total_products': len(df),
        'bait_detected': analysis_data['bait_count'],
        'false_positive_suspected': analysis_data['false_positive_count'],
        'false_negative_suspected': analysis_data['false_negative_count'],
    }

    if log_callback:
        log_callback(f"✅ AI 분석 완료!")

    return result


def _prepare_analysis_data(df) -> dict:
    """DataFrame에서 분석용 데이터 추출 (AI 학습용)"""
    data = {
        'bait_count': 0,
        'false_positive_count': 0,
        'false_negative_count': 0,
        'bait_samples': [],  # 미끼로 탐지된 샘플
        'normal_samples': [],  # ★ 정상으로 판정된 옵션들 (AI가 새 미끼 패턴 찾기용)
        'suspicious_samples': [],  # 의심스러운 정상 옵션 샘플
        'price_stats': {},
        'keyword_frequency': {},
    }

    # 컬럼명 확인 (다양한 형태 지원)
    bait_col = None
    option_col = None
    price_col = None
    product_col = None

    for col in df.columns:
        col_lower = col.lower()
        if '미끼' in col or 'bait' in col_lower:
            bait_col = col
        if '옵션' in col or 'option' in col_lower or 'sku' in col_lower:
            option_col = col
        if '가격' in col or 'price' in col_lower or '원가' in col:
            price_col = col
        if '상품' in col or 'product' in col_lower or '제목' in col:
            product_col = col

    # 미끼 탐지 통계
    if bait_col and bait_col in df.columns:
        bait_df = df[df[bait_col].notna() & (df[bait_col] != '')]
        data['bait_count'] = len(bait_df)

        # 미끼 샘플 수집 (최대 20개)
        for _, row in bait_df.head(20).iterrows():
            sample = {
                'option': str(row.get(option_col, '')) if option_col else '',
                'bait_reason': str(row.get(bait_col, '')),
                'price': row.get(price_col, 0) if price_col else 0,
                'product': str(row.get(product_col, ''))[:50] if product_col else '',
            }
            data['bait_samples'].append(sample)

    # 가격 분포
    if price_col and price_col in df.columns:
        prices = df[price_col].dropna()
        if len(prices) > 0:
            data['price_stats'] = {
                'min': float(prices.min()),
                'max': float(prices.max()),
                'median': float(prices.median()),
                'mean': float(prices.mean()),
            }

    # ★ 정상으로 판정된 옵션들 수집 (AI가 놓친 미끼 패턴 찾기)
    if option_col:
        normal_df = df[df[bait_col].isna() | (df[bait_col] == '')] if bait_col else df

        # 랜덤 샘플링으로 다양한 옵션 수집 (최대 50개)
        sample_df = normal_df.sample(n=min(50, len(normal_df))) if len(normal_df) > 50 else normal_df

        for _, row in sample_df.iterrows():
            option_text = str(row.get(option_col, ''))
            if option_text and len(option_text) > 2:  # 너무 짧은 옵션 제외
                data['normal_samples'].append({
                    'option': option_text[:100],  # 100자 제한
                    'price': row.get(price_col, 0) if price_col else 0,
                })

        # 의심되는 오탐 (정상 옵션 중 미끼 키워드 포함)
        exception_patterns = ['포함', '제공', '동봉', '세트', '구성']
        for _, row in normal_df.iterrows():
            option_text = str(row.get(option_col, ''))
            if any(p in option_text for p in exception_patterns):
                data['suspicious_samples'].append({
                    'option': option_text,
                    'price': row.get(price_col, 0) if price_col else 0,
                    'reason': 'exception_keyword_found'
                })
                if len(data['suspicious_samples']) >= 10:
                    break

    return data


def _call_gemini_api(analysis_data: dict, log_callback=None) -> dict:
    """Gemini API 호출"""
    result = {
        'success': False,
        'report': '',
        'recommendations': {
            'add_bait_keywords': [],
            'remove_bait_keywords': [],
            'add_exception_keywords': [],
            'price_threshold_suggestion': None,
        },
        'error': ''
    }

    # 프롬프트 생성
    prompt = _build_analysis_prompt(analysis_data)

    try:
        url = f"https://generativelanguage.googleapis.com/v1beta/models/{GEMINI_MODEL}:generateContent"
        headers = {
            'Content-Type': 'application/json',
        }
        payload = {
            'contents': [{
                'parts': [{'text': prompt}]
            }],
            'generationConfig': {
                'temperature': 0.3,  # 일관성 있는 분석을 위해 낮게
                'maxOutputTokens': 4096,
            }
        }

        response = requests.post(
            f"{url}?key={GEMINI_API_KEY}",
            headers=headers,
            json=payload,
            timeout=60
        )

        if response.status_code != 200:
            result['error'] = f"Gemini API 오류 ({response.status_code}): {response.text[:200]}"
            if log_callback:
                log_callback(f"❌ {result['error']}")
            return result

        response_data = response.json()

        # 응답 파싱
        if 'candidates' in response_data and len(response_data['candidates']) > 0:
            content = response_data['candidates'][0].get('content', {})
            parts = content.get('parts', [])
            if parts:
                ai_response = parts[0].get('text', '')

                # 응답 파싱 (JSON 블록 추출)
                parsed = _parse_gemini_response(ai_response)
                result['success'] = True
                result['report'] = parsed.get('report', ai_response)
                result['recommendations'] = parsed.get('recommendations', result['recommendations'])
        else:
            result['error'] = "Gemini API 응답이 비어있습니다"

    except requests.exceptions.Timeout:
        result['error'] = "Gemini API 타임아웃 (60초)"
    except Exception as e:
        result['error'] = f"Gemini API 호출 실패: {e}"

    if result['error'] and log_callback:
        log_callback(f"❌ {result['error']}")

    return result


def _build_analysis_prompt(analysis_data: dict) -> str:
    """AI 학습용 프롬프트 생성 - 정상 옵션에서 놓친 미끼 패턴 찾기"""

    bait_samples_str = ""
    for i, sample in enumerate(analysis_data['bait_samples'][:15], 1):
        bait_samples_str += f"  {i}. \"{sample['option']}\" (탐지이유: {sample['bait_reason']})\n"

    # ★ 정상으로 판정된 옵션들 (AI가 새 미끼 패턴 찾기)
    normal_samples_str = ""
    for i, sample in enumerate(analysis_data.get('normal_samples', [])[:30], 1):
        normal_samples_str += f"  {i}. \"{sample['option']}\" (가격: {sample['price']})\n"

    suspicious_str = ""
    for i, sample in enumerate(analysis_data['suspicious_samples'][:10], 1):
        suspicious_str += f"  {i}. \"{sample['option']}\" (가격: {sample['price']})\n"

    price_info = analysis_data.get('price_stats', {})
    price_str = ""
    if price_info:
        price_str = f"""
가격 분포:
- 최저가: {price_info.get('min', 'N/A')}
- 최고가: {price_info.get('max', 'N/A')}
- 중간값: {price_info.get('median', 'N/A')}
- 평균: {price_info.get('mean', 'N/A'):.2f}
"""

    prompt = f"""당신은 타오바오/알리바바 상품 옵션 분석 전문가입니다.
구매대행 시스템에서 "미끼 옵션"을 자동 필터링하는데, 현재 시스템이 놓친 미끼 패턴을 찾아주세요.

## 미끼 옵션이란?
타오바오 판매자들이 사용하는 가짜 옵션:
- 주문제작/맞춤제작 유도 ("커스텀", "정금", "계약금")
- 배송비/추가비용 결제용 ("배송비", "설치비")
- 문의/상담 유도 ("문의하세요", "상담필수")
- 안내문/홍보문구 ("감사합니다", "팔로우해주세요", "약속드립니다")
- 샘플/테스트용 ("샘플", "무료체험")
- 품절/판매종료 ("품절", "재고없음")

## 현재 탐지 결과

탐지된 미끼: {analysis_data['bait_count']}건
{bait_samples_str if bait_samples_str else "  (없음)"}

## ★ 정상으로 판정된 옵션들 (여기서 놓친 미끼를 찾아주세요!)

{normal_samples_str if normal_samples_str else "  (데이터 없음)"}

{price_str}

## 분석 요청

위 "정상으로 판정된 옵션들"을 검토하고:
1. **놓친 미끼 옵션**을 찾아주세요 (안내문, 홍보문구, 문의유도 등)
2. 해당 옵션에서 **추출할 수 있는 키워드**를 알려주세요
3. 오탐 가능성이 있는 키워드는 제외해주세요

반드시 다음 JSON 형식으로만 답변하세요:

```json
{{
  "add_bait_keywords": ["새로찾은키워드1", "새로찾은키워드2"],
  "found_bait_options": ["놓친미끼옵션1", "놓친미끼옵션2"],
  "analysis": "간단한 분석 (2-3문장)"
}}
```
"""

    return prompt


def _parse_gemini_response(response_text: str) -> dict:
    """Gemini 응답 파싱"""
    result = {
        'report': response_text,
        'recommendations': {
            'add_bait_keywords': [],
            'remove_bait_keywords': [],
            'add_exception_keywords': [],
            'found_bait_options': [],  # ★ 놓친 미끼 옵션들
            'analysis': '',
            'price_threshold_suggestion': None,
        }
    }

    # JSON 블록 추출
    import re
    json_match = re.search(r'```json\s*(\{.*?\})\s*```', response_text, re.DOTALL)

    if json_match:
        try:
            json_data = json.loads(json_match.group(1))
            result['recommendations'] = {
                'add_bait_keywords': json_data.get('add_bait_keywords', []),
                'remove_bait_keywords': json_data.get('remove_bait_keywords', []),
                'add_exception_keywords': json_data.get('add_exception_keywords', []),
                'found_bait_options': json_data.get('found_bait_options', []),
                'analysis': json_data.get('analysis', ''),
                'price_threshold_suggestion': json_data.get('price_threshold_suggestion'),
            }
            # 리포트에서 JSON 블록 제거
            result['report'] = response_text.replace(json_match.group(0), '').strip()
        except json.JSONDecodeError:
            pass

    return result


def generate_learning_report(analysis_result: dict) -> str:
    """학습 결과를 한 페이지 리포트로 생성"""

    if not analysis_result.get('success'):
        return f"❌ 분석 실패: {analysis_result.get('error', '알 수 없는 오류')}"

    stats = analysis_result.get('statistics', {})
    recs = analysis_result.get('recommendations', {})

    report = f"""
{'='*60}
🔬 불사자 시뮬레이션 AI 분석 리포트
{'='*60}

📈 기본 통계
────────────────────────────────────
• 분석 상품 수: {stats.get('total_products', 'N/A')}개
• 미끼 탐지 수: {stats.get('bait_detected', 'N/A')}건
• 의심 오탐 수: {stats.get('false_positive_suspected', 'N/A')}건
• 의심 미탐 수: {stats.get('false_negative_suspected', 'N/A')}건

🎯 키워드 개선 권장사항
────────────────────────────────────
▶ 추가할 미끼 키워드: {', '.join(recs.get('add_bait_keywords', [])) or '없음'}
▶ 제거할 미끼 키워드: {', '.join(recs.get('remove_bait_keywords', [])) or '없음'}
▶ 추가할 예외 키워드: {', '.join(recs.get('add_exception_keywords', [])) or '없음'}
▶ 가격 기준 제안: {recs.get('price_threshold_suggestion') or '현행 유지'}위안

📝 AI 상세 분석
────────────────────────────────────
{analysis_result.get('report', '분석 내용 없음')}

{'='*60}
"""
    return report


def apply_learning_recommendations(recommendations: dict, auto_apply: bool = False, log_callback=None) -> dict:
    """
    학습 권장사항을 키워드에 적용

    Args:
        recommendations: analyze_simulation_with_gemini의 recommendations
        auto_apply: True면 자동 적용, False면 변경 내용만 반환
        log_callback: 로그 출력 함수

    Returns:
        {
            'changes': {
                'bait_added': [],
                'bait_removed': [],
                'exception_added': [],
            },
            'applied': bool
        }
    """
    result = {
        'changes': {
            'bait_added': [],
            'bait_removed': [],
            'exception_added': [],
        },
        'applied': False
    }

    # 현재 키워드 로드
    current_bait = load_bait_keywords()
    current_bait_set = set(current_bait)

    # 추가할 키워드
    add_keywords = recommendations.get('add_bait_keywords', [])
    for kw in add_keywords:
        if kw and kw not in current_bait_set:
            result['changes']['bait_added'].append(kw)
            if auto_apply:
                current_bait.append(kw)

    # 제거할 키워드
    remove_keywords = recommendations.get('remove_bait_keywords', [])
    for kw in remove_keywords:
        if kw and kw in current_bait_set:
            result['changes']['bait_removed'].append(kw)
            if auto_apply:
                current_bait.remove(kw)

    # 예외 키워드 추가 (BAIT_EXCEPTION_KEYWORDS는 코드에 하드코딩되어 있어서 로그만)
    exception_keywords = recommendations.get('add_exception_keywords', [])
    for kw in exception_keywords:
        if kw and kw not in BAIT_EXCEPTION_KEYWORDS:
            result['changes']['exception_added'].append(kw)

    if auto_apply and (result['changes']['bait_added'] or result['changes']['bait_removed']):
        if save_bait_keywords(current_bait):
            result['applied'] = True
            if log_callback:
                log_callback(f"✅ 미끼 키워드 업데이트 완료")
                if result['changes']['bait_added']:
                    log_callback(f"   추가: {result['changes']['bait_added']}")
                if result['changes']['bait_removed']:
                    log_callback(f"   제거: {result['changes']['bait_removed']}")
        else:
            if log_callback:
                log_callback(f"❌ 미끼 키워드 저장 실패")

    if result['changes']['exception_added'] and log_callback:
        log_callback(f"⚠️ 예외 키워드는 코드 수정 필요: {result['changes']['exception_added']}")

    return result


# ==================== 모듈 테스트 ====================

if __name__ == "__main__":
    # Windows 콘솔 UTF-8 인코딩 설정
    import sys
    if sys.platform == 'win32':
        sys.stdout.reconfigure(encoding='utf-8')

    print("=" * 50)
    print("불사자 공통 모듈 테스트")
    print("=" * 50)

    # 키워드 로드 테스트
    print("\n[키워드 로드 테스트]")
    banned, _ = load_banned_words()
    print(f"  금지단어: {len(banned)}개")

    excluded = load_excluded_words()
    print(f"  예외단어: {len(excluded)}개")

    remove = load_remove_words()
    print(f"  제거단어: {len(remove)}개")

    bait = load_bait_keywords()
    print(f"  미끼키워드: {len(bait)}개")

    # 상품 안전 검사 테스트
    print("\n[상품 안전 검사 테스트]")
    test_titles = [
        "고급 사무용 의자 메쉬 체어",
        "유아용 기저귀 팬티형",
        "성인용품 진동기",
        "전동킥보드 접이식",
    ]
    for title in test_titles:
        result = check_product_safety(title)
        status = "✅ 안전" if result['is_safe'] else f"⚠️ 위험: {result['all_found']}"
        print(f"  '{title[:20]}...' → {status}")

    # Gemini API 연결 테스트
    print("\n[Gemini API 연결 테스트]")
    try:
        test_url = f"https://generativelanguage.googleapis.com/v1beta/models/{GEMINI_MODEL}:generateContent"
        test_payload = {
            'contents': [{'parts': [{'text': '안녕하세요. 테스트입니다.'}]}],
            'generationConfig': {'maxOutputTokens': 50}
        }
        response = requests.post(
            f"{test_url}?key={GEMINI_API_KEY}",
            headers={'Content-Type': 'application/json'},
            json=test_payload,
            timeout=10
        )
        if response.status_code == 200:
            print(f"  ✅ Gemini API 연결 성공 (모델: {GEMINI_MODEL})")
        else:
            print(f"  ❌ Gemini API 오류: {response.status_code}")
    except Exception as e:
        print(f"  ❌ Gemini API 연결 실패: {e}")

    print("\n테스트 완료!")


# ==================== 형태소 분석 (지재권 의심 단어 추출) ====================

# 형태소 분석기 초기화 (lazy loading)
_morpheme_analyzer = None

def _get_morpheme_analyzer():
    """형태소 분석기 가져오기 (lazy loading) - Kiwi 사용"""
    global _morpheme_analyzer
    if _morpheme_analyzer is None:
        try:
            from kiwipiepy import Kiwi
            kiwi = Kiwi()
            _morpheme_analyzer = ('kiwi', kiwi)
            print("[INFO] Kiwi 형태소 분석기 로드됨")
        except ImportError:
            print("[WARNING] Kiwi 설치 필요: pip install kiwipiepy")
            _morpheme_analyzer = (None, None)
    return _morpheme_analyzer


def extract_suspicious_words(text: str) -> List[Dict]:
    """
    상품명에서 지재권 의심 단어 추출

    형태소 분석으로 일반명사 제외, 의심 단어만 추출
    - 고유명사 (NNP)
    - 미등록어/외래어
    - 영어 단어

    Args:
        text: 상품명

    Returns:
        [{'word': '나이키', 'type': 'foreign', 'reason': '외래어/미등록어'}, ...]
    """
    suspicious = []

    # 1. 영어 단어 추출 (정규식)
    import re
    english_words = re.findall(r'[A-Za-z]{2,}', text)
    for word in english_words:
        # 일반적인 영어 단어 제외 (size, color 등)
        common_english = {'size', 'color', 'free', 'one', 'new', 'hot', 'best', 'top',
                         'big', 'small', 'large', 'medium', 'mini', 'max', 'pro', 'plus',
                         'set', 'box', 'pack', 'cm', 'mm', 'kg', 'ml', 'pcs', 'ea'}
        if word.lower() not in common_english:
            suspicious.append({
                'word': word,
                'type': 'english',
                'reason': '영어 단어 (브랜드 가능성)'
            })

    # 2. 형태소 분석 (Kiwi)
    analyzer_type, analyzer = _get_morpheme_analyzer()

    if analyzer and analyzer_type == 'kiwi':
        try:
            # Kiwi 형태소 분석
            result = analyzer.tokenize(text)
            for token in result:
                word = token.form
                pos = token.tag  # NNP: 고유명사, SL: 외국어, NNG: 일반명사

                if len(word) < 2:
                    continue

                # 고유명사 (NNP) - 브랜드/지재권 가능성 높음
                if pos == 'NNP':
                    if not any(s['word'] == word for s in suspicious):
                        suspicious.append({
                            'word': word,
                            'type': 'proper_noun',
                            'reason': '고유명사 (지재권 가능성)'
                        })

                # 외국어 (SL) - 브랜드 가능성
                elif pos == 'SL':
                    if not any(s['word'] == word for s in suspicious):
                        suspicious.append({
                            'word': word,
                            'type': 'foreign',
                            'reason': '외래어 (지재권 가능성)'
                        })

                # 일반명사지만 외래어 느낌 (NNG)
                elif pos == 'NNG' and _is_likely_foreign_word(word):
                    if not any(s['word'] == word for s in suspicious):
                        suspicious.append({
                            'word': word,
                            'type': 'foreign',
                            'reason': '외래어/미등록어 (지재권 가능성)'
                        })

        except Exception as e:
            print(f"[WARNING] 형태소 분석 오류: {e}")

    # 3. 숫자+영어 조합 (모델명 가능성)
    model_patterns = re.findall(r'[A-Za-z]+\d+|\d+[A-Za-z]+', text)
    for pattern in model_patterns:
        if len(pattern) >= 3 and not any(s['word'] == pattern for s in suspicious):
            suspicious.append({
                'word': pattern,
                'type': 'model_number',
                'reason': '모델명 패턴 (브랜드 제품 가능성)'
            })

    return suspicious


def _is_likely_foreign_word(word: str) -> bool:
    """외래어일 가능성이 높은 단어인지 판별"""
    # 일반적인 한국어 명사는 제외
    common_korean = {
        '운동화', '신발', '가방', '옷', '바지', '티셔츠', '원피스', '치마', '자켓',
        '코트', '점퍼', '조끼', '양말', '모자', '장갑', '스카프', '벨트', '지갑',
        '시계', '안경', '반지', '목걸이', '귀걸이', '팔찌', '액세서리',
        '휴대폰', '케이스', '충전기', '이어폰', '스피커', '키보드', '마우스',
        '컵', '접시', '그릇', '냄비', '프라이팬', '도마', '칼', '수저', '젓가락',
        '의자', '책상', '소파', '침대', '서랍', '선반', '거울', '조명',
        '남성', '여성', '아동', '유아', '남자', '여자', '아이', '어린이',
        '세트', '세트', '개입', '묶음', '박스', '패키지',
        '화이트', '블랙', '레드', '블루', '그린', '핑크', '베이지', '그레이',
        '대형', '중형', '소형', '미니', '빅', '라지', '스몰',
    }

    if word in common_korean:
        return False

    # 외래어 패턴 (한글로 쓴 영어 브랜드 느낌)
    # - 받침 없이 끝나는 경우가 많음 (나이키, 아디다스, 구찌)
    # - ㅏ, ㅣ, ㅔ, ㅗ, ㅜ 로 끝나는 경우
    if len(word) >= 2:
        last_char = word[-1]
        # 받침 확인 (한글 유니코드 연산)
        if '가' <= last_char <= '힣':
            # 받침 있는지 확인
            char_code = ord(last_char) - ord('가')
            jongseong = char_code % 28
            # 받침 없으면 (jongseong == 0) 외래어 가능성
            if jongseong == 0:
                return True

    return False


def analyze_products_for_ip(products: List[Dict], log_callback=None) -> Dict:
    """
    상품 목록에서 지재권 의심 단어 분석

    Args:
        products: [{'product_name': '나이키 운동화', ...}, ...]
        log_callback: 로그 출력 함수

    Returns:
        {
            'suspicious_words': {'나이키': 5, '아디다스': 3, ...},  # 단어별 출현 횟수
            'products_with_ip': [{'product_name': ..., 'suspicious': [...]}],
            'total_analyzed': 100,
            'products_with_issues': 15
        }
    """
    def log(msg):
        if log_callback:
            log_callback(msg)
        else:
            print(msg)

    result = {
        'suspicious_words': {},
        'products_with_ip': [],
        'total_analyzed': 0,
        'products_with_issues': 0
    }

    log(f"📋 지재권 분석 시작: {len(products)}개 상품")

    for i, product in enumerate(products):
        product_name = product.get('product_name', '') or product.get('name', '') or product.get('uploadCommonProductName', '')

        if not product_name:
            continue

        result['total_analyzed'] += 1

        # 의심 단어 추출
        suspicious = extract_suspicious_words(product_name)

        if suspicious:
            result['products_with_issues'] += 1
            result['products_with_ip'].append({
                'product_name': product_name,
                'product_id': product.get('product_id', '') or product.get('id', '') or product.get('ID', ''),
                'suspicious': suspicious
            })

            # 단어별 카운트
            for s in suspicious:
                word = s['word']
                result['suspicious_words'][word] = result['suspicious_words'].get(word, 0) + 1

        # 진행 로그 (100개마다)
        if (i + 1) % 100 == 0:
            log(f"  진행: {i + 1}/{len(products)}")

    # 정렬 (출현 횟수 기준)
    result['suspicious_words'] = dict(
        sorted(result['suspicious_words'].items(), key=lambda x: x[1], reverse=True)
    )

    log(f"✅ 분석 완료: {result['products_with_issues']}개 상품에서 의심 단어 발견")
    log(f"   의심 단어 종류: {len(result['suspicious_words'])}개")

    return result


def verify_ip_words_with_ai(words: List[str], log_callback=None) -> Dict:
    """
    의심 단어를 AI로 검증하여 실제 지재권 단어인지 확인

    Args:
        words: ['나이키', '에어맥스', '운동화', ...]

    Returns:
        {
            'ip_confirmed': ['나이키', '에어맥스'],  # 지재권 확정
            'ip_safe': ['운동화'],  # 일반 단어
            'ip_uncertain': []  # 불확실
        }
    """
    def log(msg):
        if log_callback:
            log_callback(msg)
        else:
            print(msg)

    if not words:
        return {'ip_confirmed': [], 'ip_safe': [], 'ip_uncertain': []}

    log(f"🤖 AI 지재권 검증: {len(words)}개 단어")

    # 프롬프트 생성
    prompt = f"""다음 단어들을 분석해서 지재권(브랜드/캐릭터/상표) 여부를 판별해주세요.

단어 목록:
{', '.join(words[:50])}  # 최대 50개씩

각 단어에 대해 다음 형식으로 답변해주세요:
- 단어: [IP/SAFE/UNCERTAIN] - 이유

예시:
- 나이키: IP - 스포츠 브랜드
- 운동화: SAFE - 일반명사
- 에어맥스: IP - 나이키 제품 라인

JSON 형식으로도 답변해주세요:
{{"ip": ["나이키", "에어맥스"], "safe": ["운동화"], "uncertain": []}}
"""

    try:
        # Gemini API 호출
        response = call_ai_api(prompt, timeout=30)

        if response:
            # JSON 파싱 시도
            import re
            json_match = re.search(r'\{[^{}]*"ip"[^{}]*\}', response, re.DOTALL)
            if json_match:
                try:
                    result_json = json.loads(json_match.group())
                    return {
                        'ip_confirmed': result_json.get('ip', []),
                        'ip_safe': result_json.get('safe', []),
                        'ip_uncertain': result_json.get('uncertain', [])
                    }
                except:
                    pass

            # 텍스트 파싱 폴백
            ip_confirmed = []
            ip_safe = []
            for word in words:
                if f"{word}: IP" in response or f"{word}:IP" in response:
                    ip_confirmed.append(word)
                elif f"{word}: SAFE" in response or f"{word}:SAFE" in response:
                    ip_safe.append(word)

            return {
                'ip_confirmed': ip_confirmed,
                'ip_safe': ip_safe,
                'ip_uncertain': [w for w in words if w not in ip_confirmed and w not in ip_safe]
            }

    except Exception as e:
        log(f"❌ AI 검증 실패: {e}")

    return {'ip_confirmed': [], 'ip_safe': [], 'ip_uncertain': words}


# 지재권 단어 DB 파일
IP_WORDS_FILE = "ip_words.json"

def load_ip_words() -> Dict:
    """지재권 단어 DB 로드"""
    if os.path.exists(IP_WORDS_FILE):
        try:
            with open(IP_WORDS_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            pass
    return {
        'brands': [],      # 브랜드 (나이키, 아디다스)
        'characters': [],  # 캐릭터 (디즈니, 포켓몬)
        'trademarks': [],  # 상표
        'safe_words': []   # 확인된 안전 단어
    }


def save_ip_words(data: Dict) -> bool:
    """지재권 단어 DB 저장"""
    try:
        with open(IP_WORDS_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        print(f"지재권 DB 저장 실패: {e}")
        return False


def add_ip_words(words: List[str], category: str = 'brands') -> bool:
    """지재권 단어 추가"""
    data = load_ip_words()
    if category not in data:
        data[category] = []

    added = 0
    for word in words:
        if word and word not in data[category]:
            data[category].append(word)
            added += 1

    if added > 0:
        save_ip_words(data)
        print(f"✅ {added}개 단어 추가됨 ({category})")

    return added > 0


# ==================== 상품명 검수 (의심 단어 탐지) ====================

# 상품명 검수 결과 캐시 파일
PRODUCT_NAME_CHECK_CACHE_FILE = "product_name_check_cache.json"

# 기본 의심 패턴 (패턴 → 카테고리)
DEFAULT_SUSPICIOUS_PATTERNS = {
    # 유명 브랜드 (확실한 지재권)
    'brands': [
        # 스포츠 브랜드
        '나이키', 'nike', '아디다스', 'adidas', '퓨마', 'puma', '뉴발란스', 'new balance',
        '아식스', 'asics', '리복', 'reebok', '미즈노', 'mizuno', '필라', 'fila', '카파', 'kappa',
        '언더아머', 'under armour', '스케쳐스', 'skechers', '살로몬', 'salomon', '브룩스', 'brooks',
        '디아도라', 'diadora', '엄브로', 'umbro', '컬럼비아', 'columbia', '데상트', 'descente',
        '오니츠카타이거', 'onitsuka tiger', '르꼬끄', 'le coq sportif', '라코스테', 'lacoste',
        '콘버스', 'converse', '반스', 'vans', '크록스', 'crocs',
        # 골프 브랜드
        '타이틀리스트', 'titleist', '캘러웨이', 'callaway', '테일러메이드', 'taylormade',
        '클리블랜드', 'cleveland', '코브라', 'cobra', '스릭슨', 'srixon', '핑', 'ping',
        '던롭', 'dunlop', '윌슨', 'wilson', '요넥스', 'yonex', '프린스', 'prince',
        # 명품 브랜드
        '구찌', 'gucci', '루이비통', 'louis vuitton', 'lv', '샤넬', 'chanel', '프라다', 'prada',
        '버버리', 'burberry', '에르메스', 'hermes', '디올', 'dior', '펜디', 'fendi',
        '발렌시아가', 'balenciaga', '보테가베네타', 'bottega veneta', '지방시', 'givenchy',
        '발렌티노', 'valentino', '베르사체', 'versace', '아르마니', 'armani', '돌체앤가바나', 'dolce gabbana',
        '이브생로랑', 'ysl', '셀린느', 'celine', '로에베', 'loewe', '톰브라운', 'thom browne',
        '몽클레어', 'moncler', '스톤아일랜드', 'stone island', '막스마라', 'max mara',
        '캘빈클라인', 'calvin klein', 'ck', '타미힐피거', 'tommy hilfiger', '휴고보스', 'hugo boss',
        '켄조', 'kenzo', '꼼데가르송', 'comme des garcons', '메종마르지엘라', 'maison margiela',
        '코치', 'coach', '마이클코어스', 'michael kors', '토리버치', 'tory burch', '케이트스페이드', 'kate spade',
        '롱샴', 'longchamp', '키플링', 'kipling',
        # SPA/일반 패션
        '자라', 'zara', '갭', 'gap', '유니클로', 'uniqlo', '에이치앤엠', 'h&m', '망고', 'mango',
        '코스', 'cos', '폴로', 'polo', '랄프로렌', 'ralph lauren', '게스', 'guess',
        '디젤', 'diesel', '리바이스', 'levis', '프레드페리', 'fred perry',
        # 아웃도어
        '노스페이스', 'north face', '파타고니아', 'patagonia', '아크테릭스', 'arcteryx',
        '캐나다구스', 'canada goose', '무스너클', 'moose knuckles', '몽벨', 'montbell',
        '밀레', 'millet', '마무트', 'mammut', '블랙야크', 'black yak', '네파', 'nepa', '아이더', 'eider',
        '케이투', 'k2', '헤드', 'head', '호카', 'hoka',
        # 가전/전자
        '이케아', 'ikea', '다이슨', 'dyson', '필립스', 'philips', '보쉬', 'bosch',
        '삼성', 'samsung', '엘지', 'lg', '애플', 'apple', '소니', 'sony', '파나소닉', 'panasonic',
        '캐논', 'canon', '니콘', 'nikon', '올림푸스', 'olympus', '후지필름', 'fujifilm', '라이카', 'leica',
        '델', 'dell', '에이서', 'acer', '에이수스', 'asus', '엠에스아이', 'msi', '레노버', 'lenovo',
        '인텔', 'intel', '엔비디아', 'nvidia', '에이엠디', 'amd',
        '보스', 'bose', '뱅앤올룹슨', 'bang olufsen', '제이비엘', 'jbl', '젠하이저', 'sennheiser',
        '고프로', 'gopro', '앵커', 'anker', '벨킨', 'belkin', '오터박스', 'otterbox',
        '네스프레소', 'nespresso', '드롱기', 'delonghi', '브라운', 'braun', '키친에이드', 'kitchenaid',
        '피슬러', 'fissler', '헹켈스', 'henckels', '츠빌링', 'zwilling', '스타우브', 'staub', '테팔', 'tefal',
        '르크루제', 'le creuset', '코렐', 'corelle', '락앤락', 'lock&lock',
        '바이타믹스', 'vitamix', '타퍼웨어', 'tupperware',
        # 화장품
        '로레알', 'loreal', '랑콤', 'lancome', '에스티로더', 'estee lauder', '맥', 'mac',
        '시세이도', 'shiseido', '클리니크', 'clinique', '키엘', 'kiehls', '바비브라운', 'bobbi brown',
        '나스', 'nars', '베네피트', 'benefit', '어반디케이', 'urban decay',
        '라네즈', 'laneige', '설화수', 'sulwhasoo', '헤라', 'hera', '오휘', 'ohui', '후', 'whoo',
        '이니스프리', 'innisfree', '에뛰드', 'etude', '더페이스샵', 'the face shop', '토니모리', 'tonymoly',
        '마몽드', 'mamonde', '아이오페', 'iope', '에스케이투', 'sk-ii',
        # 식음료
        '스타벅스', 'starbucks', '맥도날드', 'mcdonalds', '버거킹', 'burger king',
        '코카콜라', 'coca cola', '펩시', 'pepsi', '게토레이', 'gatorade', '레드불', 'red bull',
        '네슬레', 'nestle', '오레오', 'oreo', '프링글스', 'pringles', '배스킨라빈스', 'baskin robbins',
        # 자동차
        '벤츠', 'mercedes', 'benz', '비엠더블유', 'bmw', '아우디', 'audi', '폭스바겐', 'volkswagen',
        '포르쉐', 'porsche', '페라리', 'ferrari', '람보르기니', 'lamborghini', '마세라티', 'maserati',
        '재규어', 'jaguar', '랜드로버', 'land rover', '벤틀리', 'bentley', '롤스로이스', 'rolls royce',
        '렉서스', 'lexus', '토요타', 'toyota', '혼다', 'honda', '닛산', 'nissan',
        '테슬라', 'tesla', '현대', 'hyundai', '기아', 'kia', '제네시스', 'genesis',
        '쉐보레', 'chevrolet', '포드', 'ford', '캐딜락', 'cadillac', '볼보', 'volvo',
        # 완구/게임
        '레고', 'lego', '반다이', 'bandai', '타카라토미', 'takara tomy',
        '닌텐도', 'nintendo', '플레이스테이션', 'playstation', '엑스박스', 'xbox',
        '블리자드', 'blizzard', '이에이', 'ea sports',
        # IT/서비스
        '구글', 'google', '마이크로소프트', 'microsoft', '아마존', 'amazon', '메타', 'meta',
        '넷플릭스', 'netflix', '유튜브', 'youtube', '네이버', 'naver', '카카오', 'kakao',
        '어도비', 'adobe', '포토샵', 'photoshop',
        # 시계/주얼리
        '롤렉스', 'rolex', '오메가', 'omega', '까르띠에', 'cartier', '티파니', 'tiffany',
        # 침구/가구
        '시몬스', 'simmons', '씰리', 'sealy', '템퍼', 'tempur',
    ],
    # 캐릭터/IP (확실한 지재권)
    'characters': [
        # 디즈니/픽사
        '디즈니', 'disney', '픽사', 'pixar', '미키마우스', 'mickey', '미니마우스', 'minnie',
        '푸우', 'pooh', '엘사', 'elsa', '안나', 'anna', '모아나', 'moana', '라푼젤', 'rapunzel',
        '신데렐라', 'cinderella', '알라딘', 'aladdin', '자스민', 'jasmine', '니모', 'nemo', '도리', 'dory',
        '라이온킹', 'lion king', '심바', 'simba', '버즈라이트이어', 'buzz lightyear', '우디', 'woody',
        '토이스토리', 'toy story', '겨울왕국', 'frozen', '올라프', 'olaf', '구피', 'goofy', '도날드덕', 'donald duck',
        # 마블/DC
        '마블', 'marvel', '어벤져스', 'avengers', '스파이더맨', 'spiderman', '아이언맨', 'ironman',
        '캡틴아메리카', 'captain america', '토르', 'thor', '헐크', 'hulk', '타노스', 'thanos', '로키', 'loki',
        '배트맨', 'batman', 'dc코믹스', '슈퍼맨', 'superman', '원더우먼', 'wonder woman',
        # 일본 애니/만화
        '포켓몬', 'pokemon', '피카츄', 'pikachu', '리자몽', 'charizard', '이브이', 'eevee', '뮤', 'mew', '뮤츠', 'mewtwo', '잠만보', 'snorlax',
        '원피스', 'onepiece', '루피', 'luffy', '나루토', 'naruto', '드래곤볼', 'dragonball', '손오공', 'goku',
        '귀멸의칼날', 'demon slayer', '렌고쿠', '네즈코', '주술회전', '진격의거인',
        '짱구', '크레용신짱', '도라에몽', 'doraemon', '세일러문', 'sailor moon', '토토로', 'totoro', '지브리', 'ghibli',
        '슬램덩크', '강백호', '서태웅', '원신', 'genshin',
        # 산리오
        '헬로키티', 'hello kitty', '키티', 'kitty', '산리오', 'sanrio', '마이멜로디', 'my melody',
        '쿠로미', 'kuromi', '시나몬롤', 'cinnamoroll', '폼폼푸린', 'pompompurin', '포차코', 'pochacco',
        '케로피', 'keroppi', '구데타마', 'gudetama', '리틀트윈스타', 'little twin stars',
        # 한국 캐릭터
        '카카오프렌즈', '라이언', '어피치', '무지', '콘', '튜브', '네오', '프로도', '제이지',
        '라인프렌즈', '브라운', '코니', '샐리', '문', '제임스',
        '뽀로로', '핑크퐁', '아기상어', 'baby shark', '로보카폴리',
        # 닌텐도
        '마리오', 'mario', '루이지', 'luigi', '젤다', 'zelda', '링크', 'link', '동키콩', 'donkey kong',
        '커비', 'kirby', '동물의숲', 'animal crossing', '포켓몬고', 'pokemon go',
        # 기타
        '스타워즈', 'star wars', '요다', 'yoda', '다스베이더', 'darth vader', '만달로리안', 'mandalorian',
        '해리포터', 'harry potter', '호그와트', 'hogwarts', '볼드모트',
        '트랜스포머', 'transformers', '옵티머스프라임', 'optimus prime', '범블비', 'bumblebee',
        '스폰지밥', 'spongebob', '미니언즈', 'minions', '슈렉', 'shrek',
        '앙팡맨', '호빵맨', '소닉', 'sonic',
        # 아이돌 그룹
        '방탄소년단', 'bts', '블랙핑크', 'blackpink', '트와이스', 'twice', '엑소', 'exo', '세븐틴',
        '에스파', 'aespa', '뉴진스', 'newjeans', '르세라핌', 'le sserafim', '아이브', 'ive',
        '에이티즈', 'ateez', '스트레이키즈', 'stray kids', '엔시티', 'nct', '더보이즈', 'the boyz',
        '마마무', 'mamamoo', '레드벨벳', 'red velvet', '잇지', 'itzy', '스테이씨', 'stayc', '엔하이픈', 'enhypen',
        # 한국 연예인 (초상권)
        '지드래곤', 'g-dragon', '아이유', 'iu', '싸이', 'psy',
        # 배우
        '김고은', '김선호', '김소현', '김수현', '김유정', '김지원', '김태희', '김혜수',
        '강동원', '공유', '남주혁', '박보검', '박서준', '박신혜', '박민영',
        '손예진', '송강', '송강호', '송중기', '송혜교', '이민호', '이병헌', '이정재',
        '이종석', '이준기', '전지현', '정해인', '조인성', '차은우', '현빈', '공효진',
        '유아인', '마동석', '이동욱', '정소민', '변우석', '안효섭', '김세정',
        # MC/예능인
        '유재석', '강호동', '이경규', '신동엽', '박명수', '이영자', '김구라', '김숙',
        '전현무', '양세찬', '양세형', '지석진', '송은이', '김희철', '이상민',
        '박나래', '이국주', '박성광', '장윤정', '이승기',
        # 유튜버/인플루언서
        '대도서관', '도티', '기안84', '곽튜브', '이말년', '나영석',
        # 가수 (솔로)
        '아이유', '태양', '지드래곤', '테이', '성시경', '이효리', '솔라', '화사',
        '임영웅', '장원영', '김채원', '카리나', '윈터', '제니', '지수', '로제', '리사',
        '나연', '다현', '사나', '모모', '쯔위',
        # 해외 연예인 (초상권)
        '테일러스위프트', 'taylor swift', '아리아나그란데', 'ariana grande',
        '비욘세', 'beyonce', '빌리아일리시', 'billie eilish', '저스틴비버', 'justin bieber',
        '브루노마스', 'bruno mars', '에드시런', 'ed sheeran', '레이디가가', 'lady gaga',
        '브래드피트', 'brad pitt', '톰크루즈', 'tom cruise', '레오나르도디카프리오', 'leonardo dicaprio',
        '로버트다우니주니어', 'robert downey jr', '일론머스크', 'elon musk', '빌게이츠', 'bill gates',
        # 한국 스포츠 스타 (초상권)
        '손흥민', '김연아', '류현진', '박지성', '기성용', '이강인', '김민재',
        '박세리', '박인비', '고진영', '이정후', '이대호', '추신수', '박찬호', '이승엽',
        '김연경', '이동국', '이청용',
        # 해외 스포츠 스타 (초상권)
        '호날두', 'ronaldo', 'cr7', '메시', 'messi', '네이마르', 'neymar', '음바페', 'mbappe',
        '르브론제임스', 'lebron james', '마이클조던', 'michael jordan', '스테판커리', 'stephen curry',
        '로저페더러', 'roger federer', '라파엘나달', 'rafael nadal', '타이거우즈', 'tiger woods',
    ],
    # 금지 품목 (판매 불가)
    'prohibited': [
        # 성인용품/선정적
        '딜도', 'dildo', '러브돌', '러브젤', '바이브레이터', 'vibrator', '콘돔', 'condom',
        '페티쉬', 'fetish', '누드', 'nude', '포르노', 'porn', '섹스', 'sex', '오럴', 'oral',
        '노출', '유흥', '매춘', '근친',
        # 무기류
        '도검', '일본도', '작살총', '전기충격기', '비비탄', '너프건', '에어소프트건',
        # 약물/의약품
        '마약', '대마', '대마초', 'lsd', '니코틴', '담배', 'iqos', '낙태약',
        '다이어트약', '다이어트효과', '당뇨치료',
        '실데나필', 'sildenafil', '타다라필', 'tadalafil', '시부트라민',
        # 판매 금지 품목 (의료기기/유아용품)
        '휠체어', '유모차', '의료용', '의료기기', '안경', '렌즈', '콘택트렌즈',
        # 도박
        '도박', '카지노', 'casino',
        # 불법 촬영
        '도촬', '몰카',
    ],
    # 의심 패턴 (AI 확인 필요)
    'suspicious': [
        # 모델명 패턴
        'air max', 'air jordan', 'yeezy', 'ultraboost', 'stan smith',
        # 특정 제품명
        'airpods', 'iphone', 'ipad', 'macbook', 'galaxy', '갤럭시', '갤럭시워치', '갤럭시버즈', '갤럭시탭',
        # 게임
        '마인크래프트', 'minecraft', '포트나이트', 'fortnite', '로블록스', 'roblox',
        '배틀그라운드', 'pubg', '오버워치', 'overwatch', '리그오브레전드', 'lol',
        '발로란트', 'valorant', '디아블로', 'diablo', '리니지',
        # 기타
        'fda승인', '특허',
    ]
}


def load_product_name_check_cache() -> Dict:
    """상품명 검수 결과 캐시 로드"""
    if os.path.exists(PRODUCT_NAME_CHECK_CACHE_FILE):
        try:
            with open(PRODUCT_NAME_CHECK_CACHE_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            pass
    return {
        'confirmed_ip': [],      # AI가 확정한 지재권 단어
        'confirmed_safe': [],    # AI가 확정한 안전 단어
        'user_ip': [],           # 사용자가 추가한 지재권 단어
        'user_safe': [],         # 사용자가 추가한 안전 단어
    }


def save_product_name_check_cache(cache: Dict) -> bool:
    """상품명 검수 결과 캐시 저장"""
    try:
        with open(PRODUCT_NAME_CHECK_CACHE_FILE, 'w', encoding='utf-8') as f:
            json.dump(cache, f, ensure_ascii=False, indent=2)
        return True
    except:
        return False


def check_product_name_suspicious(product_name: str, use_ai: bool = False, log_callback=None) -> Dict:
    """
    상품명에서 의심 단어 검수

    1단계: 패턴 DB 매칭 (빠름)
    2단계: AI 검증 (use_ai=True일 때만, 패턴에 없는 단어)

    Args:
        product_name: 상품명
        use_ai: AI 검증 사용 여부
        log_callback: 로그 함수

    Returns:
        {
            'suspicious_words': [
                {'word': '나이키', 'category': 'brands', 'source': 'pattern', 'confirmed': True},
                {'word': 'Airmax', 'category': 'suspicious', 'source': 'ai', 'confirmed': True},
            ],
            'safe_words': ['운동화', '신발'],
            'needs_ai_check': ['미확인단어'],  # AI 확인 필요한 단어
            'highlighted_name': '<span>...</span>',  # HTML 강조 표시
        }
    """
    def log(msg):
        if log_callback:
            log_callback(msg)

    result = {
        'suspicious_words': [],
        'safe_words': [],
        'needs_ai_check': [],
        'highlighted_name': product_name,
    }

    if not product_name:
        return result

    cache = load_product_name_check_cache()
    product_name_lower = product_name.lower()

    found_suspicious = []
    found_safe = []
    needs_check = []

    # 1. 패턴 DB 매칭 (브랜드, 캐릭터)
    for category, patterns in DEFAULT_SUSPICIOUS_PATTERNS.items():
        for pattern in patterns:
            pattern_lower = pattern.lower()
            if pattern_lower in product_name_lower:
                # 실제 매칭된 단어 찾기 (대소문자 유지)
                import re
                match = re.search(re.escape(pattern), product_name, re.IGNORECASE)
                if match:
                    matched_word = match.group()
                    if not any(w['word'].lower() == matched_word.lower() for w in found_suspicious):
                        is_confirmed = category in ['brands', 'characters']
                        found_suspicious.append({
                            'word': matched_word,
                            'category': category,
                            'source': 'pattern',
                            'confirmed': is_confirmed
                        })

    # 2. 캐시에서 확인 (사용자 추가 / AI 확정)
    for word in cache.get('confirmed_ip', []) + cache.get('user_ip', []):
        if word.lower() in product_name_lower:
            import re
            match = re.search(re.escape(word), product_name, re.IGNORECASE)
            if match and not any(w['word'].lower() == match.group().lower() for w in found_suspicious):
                found_suspicious.append({
                    'word': match.group(),
                    'category': 'cached_ip',
                    'source': 'cache',
                    'confirmed': True
                })

    for word in cache.get('confirmed_safe', []) + cache.get('user_safe', []):
        if word.lower() in product_name_lower:
            found_safe.append(word)

    # 3. 형태소 분석으로 추가 의심 단어 추출
    suspicious_from_morpheme = extract_suspicious_words(product_name)
    for s in suspicious_from_morpheme:
        word = s['word']
        word_lower = word.lower()

        # 이미 처리됨?
        if any(w['word'].lower() == word_lower for w in found_suspicious):
            continue
        if word_lower in [w.lower() for w in found_safe]:
            continue

        # 캐시에서 확인된 안전 단어?
        if word_lower in [w.lower() for w in cache.get('confirmed_safe', []) + cache.get('user_safe', [])]:
            found_safe.append(word)
            continue

        # AI 확인 필요
        needs_check.append(word)

    # 4. AI 검증 (선택적)
    if use_ai and needs_check:
        log(f"🤖 AI 검증 중: {needs_check[:5]}...")
        ai_result = verify_ip_words_with_ai(needs_check, log_callback)

        # AI 결과 반영
        for word in ai_result.get('ip_confirmed', []):
            found_suspicious.append({
                'word': word,
                'category': 'ai_confirmed',
                'source': 'ai',
                'confirmed': True
            })
            # 캐시에 저장
            if word not in cache.get('confirmed_ip', []):
                cache.setdefault('confirmed_ip', []).append(word)

        for word in ai_result.get('ip_safe', []):
            found_safe.append(word)
            # 캐시에 저장
            if word not in cache.get('confirmed_safe', []):
                cache.setdefault('confirmed_safe', []).append(word)

        # 불확실한 단어는 needs_check에 남김
        needs_check = ai_result.get('ip_uncertain', [])

        # 캐시 저장
        save_product_name_check_cache(cache)

    result['suspicious_words'] = found_suspicious
    result['safe_words'] = found_safe
    result['needs_ai_check'] = needs_check

    # 5. HTML 강조 표시 생성
    result['highlighted_name'] = highlight_suspicious_in_name(product_name, found_suspicious, needs_check)

    return result


def highlight_suspicious_in_name(product_name: str, suspicious_words: List[Dict], uncertain_words: List[str] = None) -> str:
    """
    상품명에서 의심 단어를 HTML로 강조 표시

    - 확정 지재권: 빨간 폰트 + 노란 배경
    - 미확정 의심: 주황 폰트 + 연노란 배경

    Returns:
        HTML 문자열
    """
    import re

    if not product_name:
        return ""

    if not suspicious_words and not uncertain_words:
        return product_name

    highlighted = product_name

    # 확정 지재권 단어 강조 (빨간 폰트 + 노란 배경)
    for item in (suspicious_words or []):
        word = item.get('word', '')
        if word:
            # 대소문자 무시 교체
            pattern = re.compile(re.escape(word), re.IGNORECASE)
            highlighted = pattern.sub(
                f'<span style="color: red; background-color: yellow; font-weight: bold;">{word}</span>',
                highlighted
            )

    # 미확정 의심 단어 강조 (주황 폰트 + 연노란 배경)
    for word in (uncertain_words or []):
        if word:
            pattern = re.compile(re.escape(word), re.IGNORECASE)
            highlighted = pattern.sub(
                f'<span style="color: #FF6600; background-color: #FFFACD;">{word}</span>',
                highlighted
            )

    return highlighted


def batch_check_product_names(products: List[Dict], use_ai: bool = False, log_callback=None) -> List[Dict]:
    """
    여러 상품의 상품명 일괄 검수

    Args:
        products: [{'uploadCommonProductName': '...', ...}, ...]
        use_ai: AI 검증 사용 여부

    Returns:
        products 리스트에 'name_check_result' 필드 추가
    """
    def log(msg):
        if log_callback:
            log_callback(msg)

    all_needs_check = set()
    results = []

    log(f"📋 상품명 검수 시작: {len(products)}개")

    # 1단계: 패턴 매칭 (빠름)
    for i, product in enumerate(products):
        name = product.get('uploadCommonProductName', '') or product.get('product_name', '') or product.get('name', '')
        check_result = check_product_name_suspicious(name, use_ai=False)
        product['name_check_result'] = check_result
        all_needs_check.update(check_result.get('needs_ai_check', []))

        if (i + 1) % 100 == 0:
            log(f"  패턴 검수: {i + 1}/{len(products)}")

    # 2단계: AI 검증 (일괄, 선택적)
    if use_ai and all_needs_check:
        log(f"🤖 AI 일괄 검증: {len(all_needs_check)}개 단어")
        ai_result = verify_ip_words_with_ai(list(all_needs_check)[:50], log_callback)

        # 캐시 업데이트
        cache = load_product_name_check_cache()
        for word in ai_result.get('ip_confirmed', []):
            if word not in cache.get('confirmed_ip', []):
                cache.setdefault('confirmed_ip', []).append(word)
        for word in ai_result.get('ip_safe', []):
            if word not in cache.get('confirmed_safe', []):
                cache.setdefault('confirmed_safe', []).append(word)
        save_product_name_check_cache(cache)

        # 결과 재반영
        for product in products:
            name = product.get('uploadCommonProductName', '') or product.get('product_name', '') or product.get('name', '')
            # 재검수 (캐시 활용)
            product['name_check_result'] = check_product_name_suspicious(name, use_ai=False)

    # 통계
    suspicious_count = sum(1 for p in products if p.get('name_check_result', {}).get('suspicious_words'))
    log(f"✅ 검수 완료: {suspicious_count}/{len(products)}개 상품에서 의심 단어 발견")

    return products


# ==================== 옵션명 정리 (패턴 기반 + AI) ====================

# 기본 패턴 (중국어 → 한국어)
DEFAULT_OPTION_PATTERNS = {
    # 색상 패턴
    '黑色': '블랙', '黑': '블랙',
    '白色': '화이트', '白': '화이트',
    '红色': '레드', '红': '레드', '紅': '레드',
    '蓝色': '블루', '蓝': '블루', '藍': '블루',
    '绿色': '그린', '绿': '그린', '綠': '그린',
    '粉色': '핑크', '粉红': '핑크', '粉': '핑크',
    '黄色': '옐로우', '黄': '옐로우', '黃': '옐로우',
    '紫色': '퍼플', '紫': '퍼플',
    '灰色': '그레이', '灰': '그레이',
    '棕色': '브라운', '棕': '브라운', '咖啡色': '브라운', '咖啡': '브라운',
    '橙色': '오렌지', '橙': '오렌지',
    '米色': '베이지', '米白': '베이지', '杏色': '베이지',
    '卡其色': '카키', '卡其': '카키',
    '军绿': '카키', '軍綠': '카키',
    '藏青': '네이비', '深蓝': '네이비', '海军蓝': '네이비',
    '酒红': '와인', '枣红': '와인', '玫红': '핫핑크',
    '金色': '골드', '金': '골드',
    '银色': '실버', '银': '실버', '銀': '실버',
    '透明': '투명', '裸色': '누드',
    '彩色': '멀티컬러', '混色': '믹스컬러', '花色': '플라워',
    '浅': '라이트', '深': '다크', '亮': '브라이트',

    # 사이즈 패턴
    '大号': 'L', '中号': 'M', '小号': 'S',
    '大码': 'L', '中码': 'M', '小码': 'S',
    '均码': '프리사이즈', '均号': '프리사이즈',
    '加大': 'XL', '特大': 'XXL', '加小': 'XS',
    '厘米': 'cm', '毫米': 'mm', '米': 'm',
    '寸': '인치', '英寸': '인치',

    # 수량/단위 패턴
    '个': '개', '只': '개', '件': '개', '条': '개', '张': '장', '片': '개',
    '双': '켤레', '对': '쌍', '套': '세트', '组': '세트', '盒': '박스',
    '包': '팩', '袋': '봉지', '瓶': '병', '罐': '캔',
    '支': '개', '把': '개', '根': '개', '块': '개', '卷': '롤',

    # 스타일/타입 패턴
    '款': '타입', 'A款': 'A타입', 'B款': 'B타입', 'C款': 'C타입', 'D款': 'D타입',
    '款式': '스타일', '风格': '스타일', '类型': '타입',
    '升级版': '업그레이드', '加强版': '강화형', '基础版': '기본형',
    '经典': '클래식', '简约': '심플', '复古': '빈티지', '时尚': '패션',
    '豪华': '럭셔리', '高档': '프리미엄', '普通': '일반',

    # 재질 패턴
    '棉': '면', '纯棉': '순면', '全棉': '순면',
    '麻': '린넨', '棉麻': '면마', '亚麻': '린넨',
    '丝': '실크', '真丝': '실크', '蕾丝': '레이스',
    '皮': '가죽', '真皮': '천연가죽', '皮革': '가죽', 'PU皮': 'PU가죽',
    '绒': '벨벳', '天鹅绒': '벨벳', '毛绒': '퍼',
    '羊毛': '울', '羊绒': '캐시미어', '毛': '울',
    '涤纶': '폴리', '聚酯': '폴리에스터', '尼龙': '나일론',
    '金属': '메탈', '不锈钢': '스테인리스', '合金': '합금',
    '塑料': '플라스틱', '硅胶': '실리콘', '橡胶': '고무',
    '木': '우드', '木质': '우드', '竹': '대나무',
    '玻璃': '유리', '陶瓷': '세라믹', '瓷': '도자기',

    # 기타 패턴
    '新款': '신상', '热卖': '인기', '爆款': '베스트',
    '限量': '한정', '特价': '특가', '促销': '세일',
    '正品': '정품', '原装': '정품',
    '无': '없음', '有': '있음', '含': '포함', '不含': '미포함',
    '送': '증정', '赠品': '사은품',
    '默认': '기본', '随机': '랜덤', '可选': '선택',
    '左': '왼쪽', '右': '오른쪽', '上': '상단', '下': '하단',
    '前': '앞', '后': '뒤', '中': '중앙',
    '长': '롱', '短': '숏', '中长': '미디',
    '厚': '두꺼운', '薄': '얇은', '中厚': '중간',
    '宽': '와이드', '窄': '슬림', '松': '루즈', '紧': '타이트',
    '单': '싱글', '双': '더블', '三': '트리플',

    # 특수 기호 변환
    '＋': '+', '×': 'x', '－': '-', '＊': '*',
    '（': '(', '）': ')', '【': '[', '】': ']',
}

# 학습된 패턴 저장 파일
OPTION_PATTERNS_FILE = "option_patterns.json"


def load_option_patterns() -> Dict[str, str]:
    """옵션명 변환 패턴 로드 (기본 + 학습된 패턴)"""
    patterns = DEFAULT_OPTION_PATTERNS.copy()

    if os.path.exists(OPTION_PATTERNS_FILE):
        try:
            with open(OPTION_PATTERNS_FILE, 'r', encoding='utf-8') as f:
                learned = json.load(f)
                patterns.update(learned)
        except Exception as e:
            print(f"[WARNING] 옵션 패턴 로드 실패: {e}")

    return patterns


def save_option_pattern(original: str, translated: str) -> bool:
    """새 옵션 변환 패턴 저장 (학습)"""
    if not original or not translated:
        return False

    # 기존 학습 패턴 로드
    learned = {}
    if os.path.exists(OPTION_PATTERNS_FILE):
        try:
            with open(OPTION_PATTERNS_FILE, 'r', encoding='utf-8') as f:
                learned = json.load(f)
        except:
            pass

    # 이미 기본 패턴에 있으면 스킵
    if original in DEFAULT_OPTION_PATTERNS:
        return False

    # 새 패턴 추가
    learned[original] = translated

    try:
        with open(OPTION_PATTERNS_FILE, 'w', encoding='utf-8') as f:
            json.dump(learned, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        print(f"[ERROR] 옵션 패턴 저장 실패: {e}")
        return False


def clean_option_name(option_name: str, patterns: Dict[str, str] = None) -> Tuple[str, bool]:
    """
    옵션명 정리 (패턴 기반)

    Args:
        option_name: 원본 옵션명 (예: "黑色 A款 大号")
        patterns: 변환 패턴 (None이면 자동 로드)

    Returns:
        (cleaned_name, fully_cleaned)
        - cleaned_name: 정리된 옵션명
        - fully_cleaned: 모든 중국어가 변환되었는지 여부
    """
    if not option_name:
        return '', True

    if patterns is None:
        patterns = load_option_patterns()

    result = option_name

    # 긴 패턴부터 먼저 적용 (부분 매칭 방지)
    sorted_patterns = sorted(patterns.items(), key=lambda x: len(x[0]), reverse=True)

    for original, translated in sorted_patterns:
        result = result.replace(original, translated)

    # 남은 중국어 확인 (CJK 유니코드 범위)
    has_chinese = any('\u4e00' <= char <= '\u9fff' for char in result)

    return result.strip(), not has_chinese


def clean_option_names_batch(option_names: List[str]) -> List[Tuple[str, str, bool]]:
    """
    여러 옵션명 일괄 정리

    Returns:
        [(original, cleaned, fully_cleaned), ...]
    """
    patterns = load_option_patterns()
    results = []

    for name in option_names:
        cleaned, fully = clean_option_name(name, patterns)
        results.append((name, cleaned, fully))

    return results


def clean_option_name_with_ai(option_name: str, log_callback=None) -> Tuple[str, bool]:
    """
    옵션명 정리 (패턴 → AI 폴백)
    패턴으로 안 되면 Gemini AI에게 물어보고, 결과를 패턴에 저장

    Returns:
        (cleaned_name, success)
    """
    def log(msg):
        if log_callback:
            log_callback(msg)

    # 1. 패턴 기반 정리 시도
    patterns = load_option_patterns()
    cleaned, fully_cleaned = clean_option_name(option_name, patterns)

    if fully_cleaned:
        return cleaned, True

    # 2. 남은 중국어 추출
    remaining_chinese = []
    for char in cleaned:
        if '\u4e00' <= char <= '\u9fff':
            remaining_chinese.append(char)

    # 연속된 중국어를 단어로 그룹화
    chinese_words = []
    current_word = ''
    for char in cleaned:
        if '\u4e00' <= char <= '\u9fff':
            current_word += char
        else:
            if current_word:
                chinese_words.append(current_word)
                current_word = ''
    if current_word:
        chinese_words.append(current_word)

    if not chinese_words:
        return cleaned, True

    # 3. Gemini AI에게 번역 요청
    log(f"🤖 AI 번역 요청: {chinese_words}")

    prompt = f"""다음 중국어 단어들을 한국어로 번역해주세요.
상품 옵션명에 사용되는 단어입니다 (색상, 사이즈, 스타일, 재질 등).
간결하게 번역하고, JSON 형식으로 응답해주세요.

단어: {', '.join(chinese_words)}

응답 형식:
{{"번역": {{"중국어1": "한국어1", "중국어2": "한국어2"}}}}"""

    try:
        success, response, error = call_ai(prompt, timeout=15)

        if not success:
            log(f"❌ AI 번역 실패: {error}")
            return cleaned, False

        # JSON 파싱
        import re
        json_match = re.search(r'\{[^{}]*"번역"[^{}]*\{[^{}]*\}[^{}]*\}', response, re.DOTALL)
        if json_match:
            try:
                result_json = json.loads(json_match.group())
                translations = result_json.get('번역', {})

                # 번역 적용 및 패턴 저장
                for cn, kr in translations.items():
                    if cn and kr:
                        cleaned = cleaned.replace(cn, kr)
                        # 새 패턴 저장 (학습)
                        if save_option_pattern(cn, kr):
                            log(f"  📚 패턴 학습: {cn} → {kr}")

                return cleaned.strip(), True
            except json.JSONDecodeError:
                pass

        # JSON 파싱 실패 시 텍스트에서 추출 시도
        for cn in chinese_words:
            # "중국어: 한국어" 패턴 찾기
            pattern = rf'{cn}\s*[:：]\s*([가-힣a-zA-Z0-9]+)'
            match = re.search(pattern, response)
            if match:
                kr = match.group(1)
                cleaned = cleaned.replace(cn, kr)
                save_option_pattern(cn, kr)
                log(f"  📚 패턴 학습: {cn} → {kr}")

        return cleaned.strip(), True

    except Exception as e:
        log(f"❌ AI 번역 오류: {e}")
        return cleaned, False


def clean_option_names_with_ai_batch(option_names: List[str], log_callback=None) -> List[Tuple[str, str, bool]]:
    """
    여러 옵션명 일괄 정리 (AI 폴백 포함)

    Returns:
        [(original, cleaned, success), ...]
    """
    def log(msg):
        if log_callback:
            log_callback(msg)

    patterns = load_option_patterns()
    results = []
    needs_ai = []

    # 1. 패턴 기반 먼저 처리
    for name in option_names:
        cleaned, fully = clean_option_name(name, patterns)
        if fully:
            results.append((name, cleaned, True))
        else:
            needs_ai.append((name, cleaned))

    if not needs_ai:
        return results

    # 2. AI가 필요한 것들에서 중국어 단어 추출
    all_chinese_words = set()
    for original, partial in needs_ai:
        for char in partial:
            if '\u4e00' <= char <= '\u9fff':
                # 연속된 중국어 단어 추출
                pass

        current_word = ''
        for char in partial:
            if '\u4e00' <= char <= '\u9fff':
                current_word += char
            else:
                if current_word:
                    all_chinese_words.add(current_word)
                    current_word = ''
        if current_word:
            all_chinese_words.add(current_word)

    if not all_chinese_words:
        # 중국어가 없으면 그대로 반환
        for original, partial in needs_ai:
            results.append((original, partial, True))
        return results

    # 3. AI에게 일괄 번역 요청
    log(f"🤖 AI 일괄 번역 요청: {len(all_chinese_words)}개 단어")

    words_list = list(all_chinese_words)[:50]  # 최대 50개
    prompt = f"""다음 중국어 단어들을 한국어로 번역해주세요.
상품 옵션명에 사용되는 단어입니다 (색상, 사이즈, 스타일, 재질 등).
간결하게 번역하고, JSON 형식으로 응답해주세요.

단어: {', '.join(words_list)}

응답 형식:
{{"번역": {{"중국어1": "한국어1", "중국어2": "한국어2"}}}}"""

    new_patterns = {}

    try:
        success, response, error = call_ai(prompt, timeout=30)

        if success:
            import re
            json_match = re.search(r'\{[^{}]*"번역"[^{}]*\{[^{}]*\}[^{}]*\}', response, re.DOTALL)
            if json_match:
                try:
                    result_json = json.loads(json_match.group())
                    new_patterns = result_json.get('번역', {})

                    # 새 패턴 저장
                    for cn, kr in new_patterns.items():
                        if cn and kr and save_option_pattern(cn, kr):
                            log(f"  📚 패턴 학습: {cn} → {kr}")
                except:
                    pass
    except Exception as e:
        log(f"❌ AI 번역 오류: {e}")

    # 4. 새 패턴 적용하여 재처리
    patterns.update(new_patterns)

    for original, partial in needs_ai:
        # 새 패턴으로 다시 정리
        cleaned = partial
        for cn, kr in new_patterns.items():
            cleaned = cleaned.replace(cn, kr)

        has_chinese = any('\u4e00' <= char <= '\u9fff' for char in cleaned)
        results.append((original, cleaned.strip(), not has_chinese))

    return results


def get_option_pattern_stats() -> Dict:
    """옵션 패턴 통계"""
    learned = {}
    if os.path.exists(OPTION_PATTERNS_FILE):
        try:
            with open(OPTION_PATTERNS_FILE, 'r', encoding='utf-8') as f:
                learned = json.load(f)
        except:
            pass

    return {
        'default_count': len(DEFAULT_OPTION_PATTERNS),
        'learned_count': len(learned),
        'total_count': len(DEFAULT_OPTION_PATTERNS) + len(learned),
        'learned_patterns': learned
    }
