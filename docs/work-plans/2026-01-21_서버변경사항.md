# 서버 변경 사항 정리 (2026-01-21)

## 현재 상태 요약

### 구현 완료
- 물갈이(리뉴얼대상) 판별 로직 (server.py line 10958-10972)
- 불사자 대시보드 UI (bulsaja_dashboard_final.html)
- 마케팅 데이터 수집 (marketing_collector.py)
- 상품 삭제 기능 (smartstore_allinone.py)

### 미구현
- 업로드 자동화 (서버에서 병렬 실행)
- WebSocket 실시간 통신
- 대시보드 버튼 동작 연동

---

## 코드 변경 필요 사항

### 1. 대시보드 JS 갈이 태그 조건 수정

**파일**: `web_system/templates/bulsaja_dashboard_final.html`

**현재 코드** (line 1082, 1146):
```javascript
const isGaliTarget = acc.stage === '운영' && revenuePercent < 60 && acc.operationDays >= 30;
```

**문제점**: 서버 로직과 불일치

**수정 방안**: 서버에서 이미 `stage`를 "리뉴얼대상"으로 판별하므로, JS에서는 stage만 확인하면 됨
```javascript
const isGaliTarget = acc.stage === '리뉴얼대상';
```

또는 `renewalReason` 필드 활용:
```javascript
const isGaliTarget = acc.renewalReason ? true : false;
```

---

### 2. 리뉴얼대상 판별 조건 (현재 서버 로직 - 확인용)

**파일**: `web_system/server.py` (line 10958-10972)

```python
# 조건1: 운영 60일 경과
if operation_days >= 60:
    stage = "리뉴얼대상"
    renewalReason = f"운영 {operation_days}일 경과"

# 조건2: 운영 30일 + 월매출 50만원 이하
elif operation_days >= 30 and month_revenue <= 500000:
    stage = "리뉴얼대상"
    renewalReason = f"매출부진 ({month_revenue:,}원)"

# 조건3: 7일 주문 0건 + 운영 7일 이상
elif orders_7d == 0 and operation_days >= 7:
    stage = "리뉴얼대상"
    renewalReason = "7일 주문 0건"
```

**조건 요약**:
| 조건 | 기준 |
|------|------|
| 1 | 운영 60일 경과 |
| 2 | 운영 30일 + 월매출 50만원 이하 |
| 3 | **7일 연속 유입수 감소** (마케팅 분석 화살표 ↓ 확인) |

### 조건3 수정 필요 (현재 → 변경)

**현재 코드** (line 10969-10972):
```python
elif orders_7d == 0 and operation_days >= 7:
    stage = "리뉴얼대상"
    renewalReason = "7일 주문 0건"
```

**변경 코드**:
```python
# 마케팅 분석에서 7일 유입 화살표 필드 확인
# (30일 누적 데이터에서 매일 +1/-1 기록, 최근 7일은 ↑↓ 이모티콘으로 표시됨)
elif traffic_trend_7d == "↓" and operation_days >= 7:
    stage = "리뉴얼대상"
    renewalReason = "7일 연속 유입수 감소"
```

**참고**: 마케팅 분석 시트에서 해당 필드명 확인 필요

---

### 3. 업로드 자동화 API 추가 (신규)

**파일**: `web_system/server.py`

**추가할 엔드포인트**:
```python
# 업로드 작업 생성
@app.post("/api/upload/start")
async def start_upload(request: UploadRequest):
    """
    {
        "group_names": ["그룹1", "그룹2", ...],
        "market_name": "스마트스토어",
        "parallel_count": 10
    }
    """

# 업로드 진행 상황 조회
@app.get("/api/upload/status/{job_id}")
async def get_upload_status(job_id: str):
    """작업 상태 조회"""

# 업로드 작업 취소
@app.post("/api/upload/cancel/{job_id}")
async def cancel_upload(job_id: str):
    """작업 취소"""
```

---

### 4. WebSocket 엔드포인트 추가 (신규)

**파일**: `web_system/server.py`

```python
from fastapi import WebSocket, WebSocketDisconnect

# WebSocket 연결 관리
class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: dict):
        for connection in self.active_connections:
            await connection.send_json(message)

manager = ConnectionManager()

@app.websocket("/ws/upload")
async def websocket_upload(websocket: WebSocket):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            # 클라이언트 메시지 처리
    except WebSocketDisconnect:
        manager.disconnect(websocket)
```

---

### 5. 업로드 워커 모듈 추가 (신규)

**파일**: `web_system/modules/upload_worker.py`

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor
from typing import List, Dict

class UploadWorker:
    def __init__(self, max_workers: int = 10):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.jobs: Dict[str, dict] = {}  # job_id -> status

    async def start_upload(self, group_names: List[str], market_name: str) -> str:
        """업로드 작업 시작, job_id 반환"""
        job_id = str(uuid.uuid4())
        self.jobs[job_id] = {
            "status": "running",
            "total": len(group_names),
            "completed": 0,
            "failed": 0,
            "current": None,
            "logs": []
        }

        # 백그라운드 실행
        asyncio.create_task(self._run_uploads(job_id, group_names, market_name))
        return job_id

    async def _run_uploads(self, job_id: str, group_names: List[str], market_name: str):
        """병렬 업로드 실행"""
        # ThreadPoolExecutor로 병렬 처리
        # 진행상황 WebSocket으로 브로드캐스트
        pass

    def get_status(self, job_id: str) -> dict:
        return self.jobs.get(job_id, {"status": "not_found"})

    def cancel(self, job_id: str) -> bool:
        if job_id in self.jobs:
            self.jobs[job_id]["status"] = "cancelled"
            return True
        return False
```

---

### 6. 대시보드 버튼 동작 추가

**파일**: `web_system/templates/bulsaja_dashboard_final.html`

**추가할 기능**:
1. 업로드 단계 클릭 → 업로드 시작 API 호출
2. 삭제 단계 클릭 → 삭제 실행 API 호출
3. WebSocket 연결 → 실시간 진행상황 표시

```javascript
// WebSocket 연결
const ws = new WebSocket(`ws://${location.host}/ws/upload`);

ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    updateProgress(data);
};

// 업로드 시작
async function startUpload(groupNames) {
    const response = await fetch('/api/upload/start', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            group_names: groupNames,
            market_name: '스마트스토어',
            parallel_count: 10
        })
    });
    const data = await response.json();
    console.log('Job started:', data.job_id);
}
```

---

## 구현 순서

1. **[즉시]** 대시보드 JS 갈이 태그 조건 수정
2. **[1단계]** upload_worker.py 생성
3. **[2단계]** server.py에 업로드 API 추가
4. **[3단계]** server.py에 WebSocket 추가
5. **[4단계]** 대시보드 버튼 동작 연동
6. **[5단계]** 테스트 및 안정화

---

## 참고: 기존 CLI 업로더 재사용

`bulsaja_uploader_cli.py`의 `CLIUploader` 클래스를 서버에서 import하여 재사용 가능:

```python
from bulsaja_uploader_cli import CLIUploader

# 설정 생성
config = {
    "token": "...",
    "market_name": "스마트스토어",
    "status_filters": ["WAIT", "FAIL"]
}

# 업로더 실행
uploader = CLIUploader(config, session_id=1, group_name="그룹명")
uploader.run()
```
